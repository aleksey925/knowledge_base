<html>
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148357635-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-148357635-1');
    </script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>Записки питониста - База знаний</title>


    <!-- Bootstrap core CSS -->
    <link rel="stylesheet"
          href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
          crossorigin="anonymous">
    <link rel="stylesheet" href="https://aleksey925.github.io/knowledge-base/static/css/base.css">

    
    <link rel="stylesheet" href="https://aleksey925.github.io/knowledge-base/static/css/knowledge-base.css">


</head>

<body>

<nav class="navbar navbar-static-top navbar-inverse">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed"
                    data-toggle="collapse" data-target="#navbar"
                    aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://aleksey925.github.io/knowledge-base/index.html">Записки питониста</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
                
    <li><a href="https://aleksey925.github.io/knowledge-base/index.html">Главная</a></li>
    <li class="active"><a href="https://aleksey925.github.io/knowledge-base/knowledge_base/index.html">База знаний</a></li>

            </ul>
        </div><!-- /.nav-collapse -->
    </div><!-- /.container -->
</nav><!-- /.navbar -->

<div class="container">

    
    <div class="row row-content">

        <div class="col-xs-12 col-sm-12">
            <h1>Python</h1>
<h1>Оглавление</h1>
<ol>
<li>
<p><h3><a href="#Настройка-системы">Настройка системы</a></h3></p>
<ul>
<li><a href="#Работа-с-несколькими-версиями-python-под-windows">Работа с несколькими версиями python под windows</a></li>
<li><a href="#Создание-portable-версии-python-для-windows">Создание portable версии python для windows</a></li>
<li><a href="#Настройка-окружения-для-разработки-на-MacOS">Настройка окружения для разработки на MacOS</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Стандартная-библиотека">Стандартная библиотека</a></h3></p>
<ul>
<li>
<p><h4><a href="#time">time</a></h4></p>
<ul>
<li><a href="#Неожиданности-при-использовании-strptime">Неожиданности при использовании strptime</a></li>
</ul>
</li>
<li>
<p><h4><a href="#contextlib">contextlib</a></h4></p>
<ul>
<li><a href="#Решение-проблемы-большого-количества-вложенных-with">Решение проблемы большого количества вложенных with</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><h3><a href="#Типы-данных">Типы данных</a></h3></p>
<ul>
<li>
<p><h4><a href="#Строки">Строки</a></h4></p>
<ul>
<li><a href="#Реализация-str-в-CPython">Реализация str в CPython</a></li>
<li><a href="#Вычисление-длинны-строки-в-байтах">Вычисление длинны строки в байтах</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Целые-числа">Целые числа</a></h4></p>
<ul>
<li><a href="#Реализация-int-в-CPython">Реализация int в CPython</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Кортежи">Кортежи</a></h4></p>
<ul>
<li><a href="#Реализация-tuple-в-CPython">Реализация tuple в CPython</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Списки">Списки</a></h4></p>
<ul>
<li><a href="#Реализация-list-в-CPython">Реализация list в CPython</a></li>
<li><a href="#Создание-строки-из-списка">Создание строки из списка</a></li>
<li><a href="#Разворот-списка">Разворот списка</a></li>
<li><a href="#Срезы">Срезы</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Словари-dict">Словари (dict)</a></h4></p>
<ul>
<li><a href="#Реализация-dict-в-CPython">Реализация dict в CPython</a>  </li>
</ul>
</li>
<li>
<p><h4><a href="#Файлы">Файлы</a></h4></p>
<ul>
<li><a href="#Кодировка-файла">Кодировка файла</a></li>
<li><a href="#Работа-с-большими-файлами">Работа с большими файлами</a></li>
<li><a href="#Изменение-прав-доступа,-владельца">Изменение прав доступа, владельца</a></li>
<li><a href="#Разбиение-файла-на-несколько-генераторов">Разбиение файла на несколько генераторов</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><h3><a href="#Функции-раздел">Функции</a></h3></p>
<ul>
<li>
<p><h4><a href="#Стандартные-функции">Стандартные функции</a></h4></p>
<ul>
<li><a href="#Попарное-объединение-элементов-итерируемых-объектов">Попарное объединение элементов итерируемых объектов</a></li>
<li><a href="#Перевод-из-одной-системы-счисления-в-другую-с-помощью-int()">Перевод из одной системы счисления в другую с помощью int()</a></li>
<li><a href="#Функция-len">len()</a></li>
<li><a href="#Функция-map">map()</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Функции">Функции</a></h4></p>
<ul>
<li><a href="#Особенности-использования-lambda-в-цикле">Особенности использования lambda в цикле</a></li>
<li><a href="#Замыкание">Замыкание</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Сопрограммы">Сопрограммы</a></h4></p>
<ul>
<li><a href="#yield-from">yield from</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><h3><a href="#Классы">Классы</a></h3></p>
<ul>
<li>
<p><h4><a href="#Объектная-модель">Объектная модель</a></h4></p>
<ul>
<li><a href="#Спец-атрибуты">Спец атрибуты</a></li>
<li><a href="#Реализация-доступа-по-индексу">Реализация доступа по индексу</a></li>
<li><a href="#Протокол-итераторов">Протокол итераторов</a></li>
<li><a href="#Отличие-__getattr__-от-__getattribute__">Отличие <code>__getattr__</code> от <code>__getatrribute__</code></a></li>
<li><a href="#MRO">MRO</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><h3><a href="#Исключения">Исключения</a></h3></p>
<ul>
<li><a href="#Извлечение-traceback">Извлечение traceback</a></li>
<li><a href="#Обработчик-для-не-перехваченных-исключений">Обработчик для не перехваченных исключений</a></li>
<li><a href="#Цепочки-исключений">Цепочки исключений</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Сборщик-мусора">Сборщик мусора</a></h3></p>
<ul>
<li><a href="#Как-работает-сборщик-мусора-(gc)">Как работает сборщик мусора (gc)</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Многозадачность">Многозадачность</a></h3></p>
<ul>
<li><a href="#Сравнение-асинхронности-и-многопоточности-Описание-роли-GIL-во-всем-этом">Сравнение асинхронности и многопоточности. Описание роли GIL во всем этом.</a></li>
<li><a href="#В-чем-отличие-конкурентности-от-многопоточности">В чем отличие конкурентности от многопоточности</a></li>
<li><a href="#Асинхронность-в-python">Асинхронность в python</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Аннотации-типов">Аннотации типов</a></h3></p>
<ul>
<li><a href="#Введение-в-type-hints">Введение</a></li>
<li><a href="#Generic-type-variables-TypeVar">Generic type variables (TypeVar)</a></li>
<li><a href="#Определение-generic-классов">Определение generic классов</a></li>
<li><a href="#Аннотирование-декораторов-ParamSpec-Concatenate">Аннотирование декораторов (ParamSpec, Concatenate)</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Оптимизация-и-профилирование">Оптимизация и профилирование</a></h3></p>
<ul>
<li>
<p><h4><a href="#Способы-измерения-производительности">Способы измерения производительности</a></h4></p>
<ul>
<li><a href="#Измерение-производительности-отдельных-функций">Измерение производительности отдельных функций</a></li>
<li><a href="#Замер-времени-работы-с-помощью-unix-программы-time">Замер времени работы с помощью unix программы time</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Примеры-написания-оптимального-кода">Примеры написания оптимального кода</a></h4></p>
<ul>
<li><a href="#Создание-списков-заполненных-определённым-числом">Создание списков заполненных определённым числом</a></li>
<li><a href="#Добавление-данных-в-список">Добавление данных в список</a></li>
</ul>
</li>
<li>
<p><h4><a href="#Советы-по-написанию-оптимального-кода">Советы по написанию оптимального кода</a></h4></p>
<ul>
<li><a href="#Мелкие-классы">Мелкие классы</a></li>
<li><a href="#Поиск-(lookup)-очень-дорогой">Поиск (lookup) очень дорогой</a></li>
<li><a href="#Ввод/вывод-(python-3.X)">Ввод/вывод (python 3.X)</a></li>
<li><a href="#Оптимизация-потребления-памяти,-способы-поиска-утечек-памяти">Оптимизация потребления памяти, способы поиска утечек памяти</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><h3><a href="#Deploy">Deploy</a></h3></p>
<ul>
<li><a href="#Публикация-библиотеки-в-PyPi">Публикация библиотеки в PyPi</a></li>
<li><a href="#Namespace-packages">Namespace packages</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Тестирование">Тестирование</a></h3></p>
<ul>
<li><a href="#Основы-тестирования">Основы тестирования</a></li>
<li><a href="#Mock">Mock</a></li>
</ul>
</li>
<li>
<p><h3><a href="#Разное">Разное</a></h3></p>
<ul>
<li><a href="#Работа-с-датой-и-временем">Работа с датой и временем</a></li>
</ul>
</li>
</ol>
<p><a name='Настройка-системы'></a></p>
<h2>Настройка системы</h2>
<p><a name='Работа-с-несколькими-версиями-python-под-windows'></a></p>
<h3>Работа с несколькими версиями python под windows</h3>
<p>Начиная с версии Python 3.3 с интерпретатором поставляется специальный 
launcher, который позволяет выбрать запускаемую версию интерпретатора.</p>
<p>Для корректной работы launcher, вы должны быть уверены, что путь к нему 
прописан в переменной окружения PATH.</p>
<p>Если вы выполните в консоли:
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>py
</code></pre></div>
Будет запущен интерпретатор выбранный по умолчанию.</p>
<p>Скрипту можно указать, какую конкретную версию нужно запустить:
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>py -2.7
</code></pre></div>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>py -3
</code></pre></div></p>
<p><a name='Создание-portable-версии-python-для-windows'></a></p>
<h3>Создание portable версии python для windows</h3>
<ol>
<li>Заходим на оф. сайт и качаем python версии «embeddable zip file»;</li>
<li>Разархивируем скачанный файл;</li>
<li>Удаляем из извлеченной папки файл с расширением <code>_pth</code>;</li>
<li>Создаем папку <code>lib</code>, извлекаем туда содержимое файла <code>&lt;версия_python&gt;.zip</code> и 
удаляем этот архив;</li>
<li>Скачиваем скрипт <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a> и запускаем его при 
помощи скачанного python;</li>
<li>Теперь можно при помощи pip установить все нужные библиотеки. </li>
</ol>
<p><a name='Настройка-окружения-для-разработки-на-MacOS'></a></p>
<h3>Настройка окружения для разработки на MacOS</h3>
<p>Данный мануал актуален для компьютеров на основе чипа Apple Silicone. В целом его можно применять и для компьютеров на
intel, но не с небольшими доработками.</p>
<ol>
<li>
<p>Устанавливаем brew. Выполнять обе команды требуется для возможности устанавливать как нативно поддерживаемые 
    приложения, так и те, которые будут работать через прослойку совместимости.</p>
<p>Устанавливает brew для архитектуры x86</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre></div>
<p>Устанавливает brew для apple silicone</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>arch -arm64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
</code></pre></div>
<p>После установки brew для m1 будет установлен в /opt/homebrew/bin/brew, а для intel /usr/local/bin/brew</p>
</li>
<li>
<p>Добавляем в ~/.zshrc и переоткрываем консоль, чтобы настройки применились</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #60a0b0; font-style: italic"># brew</span>
<span style="color: #007020; font-weight: bold">if</span> <span style="color: #666666">[[</span> <span style="color: #007020; font-weight: bold">$(</span>arch<span style="color: #007020; font-weight: bold">)</span> <span style="color: #666666">==</span> <span style="color: #4070a0">&#39;arm64&#39;</span> <span style="color: #666666">]]</span>; <span style="color: #007020; font-weight: bold">then</span>
    <span style="color: #007020">eval</span> <span style="color: #4070a0">&quot;</span><span style="color: #007020; font-weight: bold">$(</span>/opt/homebrew/bin/brew shellenv<span style="color: #007020; font-weight: bold">)</span><span style="color: #4070a0">&quot;</span>
<span style="color: #007020; font-weight: bold">else</span>
    <span style="color: #007020">eval</span> <span style="color: #4070a0">&quot;</span><span style="color: #007020; font-weight: bold">$(</span>/usr/local/bin/brew shellenv<span style="color: #007020; font-weight: bold">)</span><span style="color: #4070a0">&quot;</span>
<span style="color: #007020; font-weight: bold">fi</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">HOMEBREW_NO_ANALYTICS</span><span style="color: #666666">=</span><span style="color: #40a070">1</span>

<span style="color: #60a0b0; font-style: italic"># Poetry</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">PATH</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$HOME</span><span style="color: #4070a0">/.poetryenv/1.7.1:</span><span style="color: #bb60d5">$PATH</span><span style="color: #4070a0">&quot;</span>
poetry completions zsh &gt; ~/.zsh/_poetry

<span style="color: #60a0b0; font-style: italic"># Pyenv</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">PYENV_ROOT</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$HOME</span><span style="color: #4070a0">/.pyenv&quot;</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">PATH</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$PYENV_ROOT</span><span style="color: #4070a0">/bin:</span><span style="color: #bb60d5">$PATH</span><span style="color: #4070a0">&quot;</span>
<span style="color: #007020">eval</span> <span style="color: #4070a0">&quot;</span><span style="color: #007020; font-weight: bold">$(</span>pyenv init --path<span style="color: #007020; font-weight: bold">)</span><span style="color: #4070a0">&quot;</span>

<span style="color: #60a0b0; font-style: italic"># direnv</span>
<span style="color: #007020">eval</span> <span style="color: #4070a0">&quot;</span><span style="color: #007020; font-weight: bold">$(</span>direnv hook zsh<span style="color: #007020; font-weight: bold">)</span><span style="color: #4070a0">&quot;</span>

<span style="color: #60a0b0; font-style: italic"># Включает погрузку скриптов реализующих автодополнение в консоли</span>
zstyle <span style="color: #4070a0">&#39;:completion:*:*:git:*&#39;</span> script ~/.zsh/git-completion.bash
<span style="color: #bb60d5">fpath</span><span style="color: #666666">=(</span>~/.zsh <span style="color: #bb60d5">$fpath</span><span style="color: #666666">)</span>
autoload -Uz compinit <span style="color: #666666">&amp;&amp;</span> compinit

<span style="color: #007020">source</span> &lt;<span style="color: #666666">(</span>kubectl completion zsh<span style="color: #666666">)</span>

<span style="color: #60a0b0; font-style: italic"># Генерирует флаги необходимые для сборки из исходников сишных библиотек</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">LDFLAGS</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;&quot;</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">CPPFLAGS</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;&quot;</span>
<span style="color: #007020">export</span> <span style="color: #bb60d5">PKG_CONFIG_PATH</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;&quot;</span>

<span style="color: #bb60d5">pkgs</span><span style="color: #666666">=(</span>curl readline sqlite<span style="color: #666666">)</span>
<span style="color: #007020; font-weight: bold">for</span> pkg <span style="color: #007020; font-weight: bold">in</span> <span style="color: #bb60d5">$pkgs</span>; <span style="color: #007020; font-weight: bold">do</span>
    <span style="color: #bb60d5">pkg_dir</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$HOMEBREW_PREFIX</span><span style="color: #4070a0">/opt/</span><span style="color: #bb60d5">$pkg</span><span style="color: #4070a0">&quot;</span>

    <span style="color: #bb60d5">lib_dir</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$pkg_dir</span><span style="color: #4070a0">/lib&quot;</span>

    <span style="color: #007020; font-weight: bold">if</span> <span style="color: #666666">[</span> -d <span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$lib_dir</span><span style="color: #4070a0">&quot;</span> <span style="color: #666666">]</span>; <span style="color: #007020; font-weight: bold">then</span>
        <span style="color: #007020">export</span> <span style="color: #bb60d5">LDFLAGS</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$LDFLAGS</span><span style="color: #4070a0"> -L</span><span style="color: #bb60d5">$lib_dir</span><span style="color: #4070a0">&quot;</span>
    <span style="color: #007020; font-weight: bold">fi</span>

    <span style="color: #bb60d5">include_dir</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$pkg_dir</span><span style="color: #4070a0">/include&quot;</span>
    <span style="color: #007020; font-weight: bold">if</span> <span style="color: #666666">[</span> -d <span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$include_dir</span><span style="color: #4070a0">&quot;</span> <span style="color: #666666">]</span>; <span style="color: #007020; font-weight: bold">then</span>
        <span style="color: #007020">export</span> <span style="color: #bb60d5">CPPFLAGS</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$CPPFLAGS</span><span style="color: #4070a0"> -I</span><span style="color: #bb60d5">$include_dir</span><span style="color: #4070a0">&quot;</span>
    <span style="color: #007020; font-weight: bold">fi</span>

    <span style="color: #bb60d5">pkg_config_dir</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$lib_dir</span><span style="color: #4070a0">/pkgconfig&quot;</span>
    <span style="color: #007020; font-weight: bold">if</span> <span style="color: #666666">[</span> -d <span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$pkg_config_dir</span><span style="color: #4070a0">&quot;</span> <span style="color: #666666">]</span>; <span style="color: #007020; font-weight: bold">then</span>
        <span style="color: #007020; font-weight: bold">if</span> <span style="color: #666666">[</span> <span style="color: #4070a0">&quot;x</span><span style="color: #bb60d5">$PKG_CONFIG_PATH</span><span style="color: #4070a0">&quot;</span> <span style="color: #666666">=</span> <span style="color: #4070a0">&quot;x&quot;</span> <span style="color: #666666">]</span>; <span style="color: #007020; font-weight: bold">then</span>
            <span style="color: #007020">export</span> <span style="color: #bb60d5">PKG_CONFIG_PATH</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;</span><span style="color: #bb60d5">$pkg_config_dir</span><span style="color: #4070a0">&quot;</span>
        <span style="color: #007020; font-weight: bold">else</span>
            <span style="color: #007020">export</span> <span style="color: #bb60d5">PKG_CONFIG_PATH</span><span style="color: #666666">=</span><span style="color: #4070a0">&quot;PKG_CONFIG_PATH:</span><span style="color: #bb60d5">$pkg_config_dir</span><span style="color: #4070a0">&quot;</span>
        <span style="color: #007020; font-weight: bold">fi</span>
    <span style="color: #007020; font-weight: bold">fi</span>
<span style="color: #007020; font-weight: bold">done</span> 
</code></pre></div>
</li>
<li>
<p>Открываем консоль для работы с ПО адаптированным под Apple Silicon, чтобы у нас использовалась правильная версия 
    brew и зависимости установились правильно.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>arch -arm64 zsh
</code></pre></div>
<blockquote>
<p>P.S. Вы всегда должны загружать оболочку (zsh) для той архитектуры, с ПО для которой вы собираетесь работать.<br />
Если так не делать и просто перед вызовом программы указывать требуемую архитектуру через arch, то вы можете<br />
получить большие проблемы, так как у вас будут загружены переменные окружения указывающие не на те версии 
программ.</p>
</blockquote>
</li>
<li>
<p>Устанавливаем полезные утилиты необходимые для работы</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>brew install wget direnv bash-completion mc xz
curl https://pyenv.run | bash
curl -sSL https://raw.githubusercontent.com/aleksey925/poetryenv/master/src/poetryenv.sh -o ~/poetryenv &amp;&amp; bash ~/poetryenv self-install
</code></pre></div>
</li>
<li>
<p>Устанавливаем docker</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>brew install --cask docker
</code></pre></div>
</li>
<li>
<p>Устанавливаем poetry</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>poetryenv install --python 3.12.1 --poetry 1.7.1
poetry config virtualenvs.create false
</code></pre></div>
</li>
<li>
<p>Копируем подсказки для автодоплнения</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>mkdir -p ~/.zsh &amp;&amp; cd ~/.zsh
curl -o git-completion.bash https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash
curl -o _git https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.zsh
ln -s /Applications/Docker.app/Contents/Resources/etc/docker.zsh-completion ~/.zsh/_docker
ln -s /Applications/Docker.app/Contents/Resources/etc/docker-compose.zsh-completion ~/.zsh/_docker_compose
</code></pre></div>
</li>
<li>
<p>Устанавливаем через pyenv нужную версию python</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>pyenv install 3.12.1
</code></pre></div>
</li>
</ol>
<p><a name='Стандартная-библиотека'></a></p>
<h2>Стандартная библиотека</h2>
<p><a name='time'></a></p>
<h3>time</h3>
<p><a name='Неожиданности-при-использовании-strptime'></a></p>
<h4>Неожиданности при использовании strptime</h4>
<p>Иногда можно сталкнуться с неожиданной ошибкой при использовании функции 
strptime, которая заключается в том, что при парсиге строки содержащей в себе
временную зону отличную от установленной сейчас на ПК, возникнет ошибка:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020">ValueError</span>: time data <span style="color: #4070a0">&#39;Sat Mar 21 00:00:00 MSK 2015&#39;</span> does <span style="color: #007020; font-weight: bold">not</span> match <span style="color: #007020">format</span> <span style="color: #4070a0">&#39;</span><span style="color: #70a0d0; font-style: italic">%a</span><span style="color: #4070a0"> %b </span><span style="color: #70a0d0; font-style: italic">%d</span><span style="color: #4070a0"> %H:%M:%S %Z %Y&#39;</span>
</code></pre></div>
<p>Избежать этого можно вот так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">os</span>
<span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">time</span>

os<span style="color: #666666">.</span>environ[<span style="color: #4070a0">&#39;TZ&#39;</span>] <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;Europe/Moscow&#39;</span>
<span style="color: #007020">print</span>(time<span style="color: #666666">.</span>strptime(<span style="color: #4070a0">&#39;Sat Mar 21 00:00:00 MSK 2015&#39;</span>, <span style="color: #4070a0">&#39;</span><span style="color: #70a0d0; font-style: italic">%a</span><span style="color: #4070a0"> %b </span><span style="color: #70a0d0; font-style: italic">%d</span><span style="color: #4070a0"> %H:%M:%S %Z %Y&#39;</span>))
</code></pre></div>
<p><a name='contextlib'></a></p>
<h3>contextlib</h3>
<p><a name='Решение-проблемы-большого-количества-вложенных-with'></a></p>
<h4>Решение проблемы большого количества вложенных with</h4>
<p>Иногда бывают ситуации, когда необходимо использовать большое количество
вложенных конструкций with или в одной кострукции with необходимо работать с 
несколькими объектами. И в этих случаях, код становится некрасивым, ухудшается<br />
его читаемость, а количество симвлов в строке переваливает далеко за 80.</p>
<p>Эта ситуация неприятная и ее хочется как-то решить. К счатью, в стандартной 
библиотеке есть класс <code>contextlib.ExitStack</code>, который решает описанную выше 
проблему.</p>
<p>Для того, чтобы показать как работать с ним, предположим, что у нас есть 2 
класса: Foo и Spam.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Foo</span>:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__enter__</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;enter Foo&#39;</span>)
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span>

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__exit__</span>(<span style="color: #007020">self</span>, exc_type, exc_val, exc_tb):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;exit Foo&#39;</span>)

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">work</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;work Foo&#39;</span>)


<span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Spam</span>:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__enter__</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;enter Spam&#39;</span>)
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span>

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__exit__</span>(<span style="color: #007020">self</span>, exc_type, exc_val, exc_tb):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;exit Spam&#39;</span>)

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">work</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;work Spam&#39;</span>)
</code></pre></div>
<p>При классическом подходе работа с ними будет выглядеть так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">with</span> Foo() <span style="color: #007020; font-weight: bold">as</span> foo, Spam() <span style="color: #007020; font-weight: bold">as</span> spam:
    foo<span style="color: #666666">.</span>work()
    spam<span style="color: #666666">.</span>work()
</code></pre></div>
<p>Но, при использовании <code>ExitStack</code>, код выше можно переписать следующим образом:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">contextlib</span>

<span style="color: #007020; font-weight: bold">with</span> contextlib<span style="color: #666666">.</span>ExitStack() <span style="color: #007020; font-weight: bold">as</span> stack:
    foo <span style="color: #666666">=</span> stack<span style="color: #666666">.</span>enter_context(Foo())
    spam <span style="color: #666666">=</span> stack<span style="color: #666666">.</span>enter_context(Spam())
    foo<span style="color: #666666">.</span>work()
    spam<span style="color: #666666">.</span>work()
</code></pre></div>
<blockquote>
<p>Чаще всего, проблема с большим количеством вложенных with встречается при 
работе c асинхронным кодом. По этому, для работы с асинхронными менеджерами 
контекста есть специальный класс, который назвается <code>contextlib.AsyncExitStack</code>. </p>
</blockquote>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://docs.python.org/3.7/library/contextlib.html#contextlib.ExitStack">contextlib - ExitStack</a></li>
<li><a href="https://docs.python.org/3.7/library/contextlib.html#contextlib.AsyncExitStack">contextlib - AsyncExitStack</a></li>
</ul>
<p><a name='Типы-данных'></a></p>
<h2>Типы данных</h2>
<p><a name='Строки'></a></p>
<h3>Строки</h3>
<p><a name='Реализация-str-в-CPython'></a></p>
<h4>Реализация str в CPython</h4>
<p><a href="https://habr.com/ru/post/480324/">Реализация строкового типа в CPython</a>, <a href="https://cloud.mail.ru/public/Dzw2/jZ3H5z5Rz">копия</a></p>
<p><a name='Вычисление-длинны-строки-в-байтах'></a></p>
<h4>Вычисление длинны строки в байтах</h4>
<p>Для того, чтобы вычислить сколько байтов занимает строка нужно:
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>text <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;Какая-то строка&#39;</span>
<span style="color: #007020">print</span>(<span style="color: #007020">len</span>(text<span style="color: #666666">.</span>encode(<span style="color: #4070a0">&#39;utf8&#39;</span>)))
</code></pre></div></p>
<p><a name='Целые-числа'></a></p>
<h3>Целые числа</h3>
<p><a name='Реализация-int-в-CPython'></a></p>
<h4>Реализация int в CPython</h4>
<p><a href="https://habr.com/ru/post/455114/">Реализация целого типа в CPython</a>, <a href="https://cloud.mail.ru/public/dLCi/4pPxztZsT">копия</a></p>
<p><a name='Кортежи'></a></p>
<h3>Кортежи</h3>
<p><a name='Реализация-tuple-в-CPython'></a></p>
<h4>Реализация tuple в CPython</h4>
<p>В python кортежи имеют такую же реализацию как и списки, но с дополнительными
оптимизациями. Оптимизации основаны на том, что кортежи являются не изменяемым
типом данных и имеют фиксированный размер.</p>
<p>Во первых, нельзя создать несколько разных объектов содержащих пустой кортеж.
Python однажды создает объект содержащий пустой кортеж и потом использует его
на всем протяжении жизни программы.</p>
<p>Далее, чтобы избежать постоянного выделения памяти под маленькие кортежи. 
Python может переиспользовать созданные ранее, которые больше не 
используются в программе и имеют "малый" размер. Определение размера 
производится на основании константы <code>PyTuple_MAXSAVESIZE</code>. Таким образом все
кортежи чья длинна не превышает значение константы <code>PyTuple_MAXSAVESIZE</code>
могут быть сохранены в специальный список и потом переиспользованы. </p>
<p>Сам список хранящий объекты кортежей для повторого использования представляет 
из себя массив, который имеет длинну <code>PyTuple_MAXSAVESIZE</code>, где каждый n-й
элемент массва указывает либо на NULL (если нет кортежей размера n, которые
можно переиспользовать), либо на кортеж размеро n, который можно 
переиспользовать. Если имеется несколько кортежей одинаковой длинны, которые 
могут быть переиспользованы, то они объединяются в связанный список.
Для того, чтобы гарантировать, что не будет сохранено слишком много объектов и
они не займут всю память, существует вторая константа <code>PyTuple_MAXFREELIST</code>,
которая контролирует максимальную длинну любого из этих связанных списков, в 
любом элементе массива. Так же есть ещё один массив размера 
<code>PyTuple_MAXSAVESIZE</code>, который хранит длинну связанных списков состоящих из
кортежей. Это необходимо для контроля заданных ограничений. </p>
<p>Использованные материалы:
- <a href="http://blackecho.github.io/blog/programming/2016/03/23/python-underlying-data-structures.html">Understanding Python's underlying data structures</a>
- <a href="https://stackoverflow.com/questions/14135542/how-is-tuple-implemented-in-cpython">How is tuple implemented in CPython?</a></p>
<p><a name='Списки'></a></p>
<h3>Списки</h3>
<p><a name='Реализация-list-в-CPython'></a></p>
<h4>Реализация list в CPython</h4>
<p>В Python списки реализованы как массив хранящий ссылки на объекты типа 
<code>PyObject</code>. Такая реализация позволяет обращаться к элементу массива по 
индексу за констатное время. Увеличение размера массива происходит по 
определенному алгоритму (<a href="https://hg.python.org/cpython/file/tip/Objects/listobject.c">исходный код</a>).
Вот как будет увеличиваться размер массива при последовательном добавлении в
него новых элементов: 0, 4, 8, 16, 25, 46, 58, 72, 88, and etc.</p>
<p>Использование источники:</p>
<ul>
<li><a href="http://blackecho.github.io/blog/programming/2016/03/23/python-underlying-data-structures.html">Understanding Python's underlying data structures</a></li>
<li><a href="https://habr.com/post/273045/">Внутреннее устройство Python list</a></li>
</ul>
<p><a name='Создание-строки-из-списка'></a></p>
<h4>Создание строки из списка</h4>
<p>Свернуть список можно банально использовав цикл:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>numbers <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;1&#39;</span>, <span style="color: #4070a0">&#39;2&#39;</span>, <span style="color: #4070a0">&#39;3&#39;</span>, <span style="color: #4070a0">&#39;11&#39;</span>]
result <span style="color: #666666">=</span> <span style="color: #40a070">1</span>
<span style="color: #007020; font-weight: bold">for</span> number <span style="color: #007020; font-weight: bold">in</span> numbers:
    result <span style="color: #666666">+=</span> number
</code></pre></div>
<p>или можно красиво сделать все это в 1 строчку с помощью функции reduce</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">functools</span> <span style="color: #007020; font-weight: bold">import</span> reduce
a <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;1&#39;</span>, <span style="color: #4070a0">&#39;2&#39;</span>, <span style="color: #4070a0">&#39;3&#39;</span>, <span style="color: #4070a0">&#39;11&#39;</span>]
<span style="color: #007020">print</span>(reduce(<span style="color: #007020; font-weight: bold">lambda</span> x1, x2: x1 <span style="color: #666666">+</span> <span style="color: #4070a0">&#39;, &#39;</span> <span style="color: #666666">+</span> x2, a))
</code></pre></div>
<p>или</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>a <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;1&#39;</span>, <span style="color: #4070a0">&#39;2&#39;</span>, <span style="color: #4070a0">&#39;3&#39;</span>, <span style="color: #4070a0">&#39;11&#39;</span>]
<span style="color: #4070a0">&#39;, &#39;</span><span style="color: #666666">.</span>join(a)
</code></pre></div>
<p><a name='Разворот-списка'></a></p>
<h4>Разворот списка</h4>
<p>Развернуть список можно 2 способами:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020">print</span>(<span style="color: #007020">reversed</span>([<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>]))
</code></pre></div>
<p>или</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020">print</span>([<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>][::<span style="color: #666666">-</span><span style="color: #40a070">1</span>])
</code></pre></div>
<p><a name='Срезы'></a></p>
<h4>Срезы</h4>
<p>Очень часто, надо получить не один какой-то элемент, а некоторый их набор 
ограниченный определенными простыми правилами — например первые 5 или 
последние три, или каждый второй элемент — в таких задачах, вместо перебора 
в цикле намного удобнее использовать так называемый срез (slice, slicing).</p>
<p>Следует помнить, что взяв элемент по индексу или срезом (slice) мы не как 
не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего 
использования (например добавления в другую коллекцию, вывода на печать, 
каких-то вычислений). Поскольку сама коллекция не меняется — это применимо 
как к изменяемым (список) так и к неизменяемым (строка, кортеж) 
последовательностям.</p>
<p>Синтаксис среза похож на таковой для индексации, но в квадратных скобках 
вместо одного значения указывается 2-3 через двоеточие:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code># старт, стоп и шаг
my_collection[start:stop:step]
</code></pre></div>
<p><strong>Особенности работы со срезами</strong></p>
<ul>
<li>Отрицательные значения старта и стопа означают, что считать надо не с 
начала, а с конца коллекции.</li>
<li>Отрицательное значение шага — перебор ведём в обратном порядке справа налево.</li>
<li>Если не указан старт [:stop:step]— берём с самого начала коллекции, 
то есть start = 0</li>
<li>Если не указан стоп [start:: step] — идем до самого конца коллекции, т
о есть stop = 0</li>
<li>step = 1, то есть последовательный перебор слева направо указывать 
не обязательно — это значение шага по умолчанию. В таком случае 
достаточно указать [start:stop]</li>
<li>Можно сделать даже так [:] — это значит взять коллекцию целиком</li>
<li>ВАЖНО: При срезе, первый индекс входит в выборку, а второй нет! То есть от 
старта включительно, до стопа, где стоп не включается в результат. 
Математически это можно было бы записать как [start, stop)</li>
</ul>
<p><strong>Именованные срезы</strong></p>
<p>Чтобы избавится от «магических констант», особенно в случае, когда один и 
тот же срез надо применять многократно, можно задать константы с именованными 
срезами с пользованием специальной функции slice().</p>
<p>Примечание: Nonе соответствует опущенному значению по-умолчанию. 
То есть [:2] становится slice(None, 2), а [1::2] становится slice(1, None, 2).</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #60a0b0; font-style: italic"># задаем константам именованные срезы</span>
<span style="color: #666666">&gt;&gt;&gt;</span> NAME, BIRTHDAY <span style="color: #666666">=</span> <span style="color: #007020">slice</span>(<span style="color: #007020; font-weight: bold">None</span>, <span style="color: #40a070">2</span>), <span style="color: #007020">slice</span>(<span style="color: #40a070">2</span>, <span style="color: #007020; font-weight: bold">None</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> person <span style="color: #666666">=</span> (<span style="color: #4070a0">&#39;Alex&#39;</span>, <span style="color: #4070a0">&#39;Smith&#39;</span>, <span style="color: #4070a0">&quot;May&quot;</span>, <span style="color: #40a070">10</span>, <span style="color: #40a070">1980</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> person[NAME]
(<span style="color: #4070a0">&#39;Alex&#39;</span>, <span style="color: #4070a0">&#39;Smith&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> person[BIRTHDAY]
(<span style="color: #4070a0">&#39;May&#39;</span>, <span style="color: #40a070">10</span>, <span style="color: #40a070">1980</span>)
</code></pre></div>
<p><strong>Изменнеие списка срезом</strong></p>
<p>Добавление элементов:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>] 
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #40a070">1</span>:<span style="color: #40a070">1</span>] <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;доп. элемент1&#39;</span>, <span style="color: #4070a0">&#39;доп. элемент2&#39;</span>] 
<span style="color: #666666">&gt;&gt;&gt;</span> a 
[<span style="color: #40a070">1</span>, <span style="color: #4070a0">&#39;доп. элемент1&#39;</span>, <span style="color: #4070a0">&#39;доп. Элемент2&#39;</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>]
</code></pre></div>
<p>Замена элементов:
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>] 
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #40a070">2</span>:] <span style="color: #666666">=</span> [<span style="color: #40a070">10</span>, <span style="color: #40a070">15</span>, <span style="color: #40a070">20</span>] 
<span style="color: #666666">&gt;&gt;&gt;</span> a 
[<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">10</span>, <span style="color: #40a070">15</span>, <span style="color: #40a070">20</span>]
</code></pre></div></p>
<p>Удаление элементов:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>, <span style="color: #40a070">5</span>] 
<span style="color: #666666">&gt;&gt;&gt;</span> a[<span style="color: #40a070">2</span>:] <span style="color: #666666">=</span> [] 
<span style="color: #666666">&gt;&gt;&gt;</span> a 
[<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>]
</code></pre></div>
<p><a name='Словари-dict'></a></p>
<h3>Словари (dict)</h3>
<p><a name='Реализация-dict-в-CPython'></a></p>
<h4>Реализация dict в CPython</h4>
<blockquote>
<p>Актуально для python 3.5 и ниже </p>
</blockquote>
<p>Словари - это неупорядоченные коллекции произвольных объектов с доступом по 
ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.</p>
<p>Перед тем как реализовывать словари в python, разработчики интепретатора 
проанализировали для чего они чаще всего используются в интерпретаторе и не 
только. </p>
<p>Ниже представлена статистика, которую они собрали:</p>
<ul>
<li>именованные параметры функций<ul>
<li>1 запись</li>
<li>1-3 элемента</li>
<li>часто используется в простых программах</li>
</ul>
</li>
<li>поиск метода в классе (все методы лежат в словаре, который доступен через 
атрибут <code>__dict__</code>) <ul>
<li>1 запись, много чтений</li>
<li>8-16 элементов</li>
<li>при наследовании много неудачных чтений с последующим поиском в базовом
классе</li>
</ul>
</li>
<li>атрибуты и глобальные переменные<ul>
<li>много записей и чтений</li>
<li>4-10 элементов</li>
</ul>
</li>
<li>builtins (все встроенные функции)<ul>
<li>частые чтения, почти не бывает записи</li>
<li>~150 строковых ключей (python 3.3)</li>
<li>по некоторым ключам чтения гораздо чаще чем по другим</li>
</ul>
</li>
<li>удаление повторов, подсчет элементов<ul>
<li>однократное чтение по каждому из ключей</li>
<li>произвольное количество элементов</li>
<li>многократный доступ по одному ключу подрят</li>
</ul>
</li>
<li>проверка принадлежности<ul>
<li>словари произвольных размеров</li>
<li>создаются 1 раз и затем мало изменяются</li>
<li>много вызовов <code>has_key()</code> и <code>__contains__</code></li>
</ul>
</li>
<li>динамическое отображение (то есть происходит постоянная работа со словарем:
чередующиеся добавления, удаления, чтение и перезапись элементов) </li>
</ul>
<p>Примеры</p>
<ul>
<li>
<p>Удаление дубликатов</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020">dict</span><span style="color: #666666">.</span>fromkeys(seqn)<span style="color: #666666">.</span>keys()
</code></pre></div>
<p>Все опреации записи выполняются при конструировании.</p>
</li>
<li>
<p>Подсчет элементов в последовательности</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> seq:
    d[i] <span style="color: #666666">=</span> d<span style="color: #666666">.</span>get(i, <span style="color: #40a070">0</span>) <span style="color: #666666">+</span> <span style="color: #40a070">1</span>  
</code></pre></div>
<p>Выполняется 2 последовательных доступа по ключу и используя метод get мы
не можем уменьшить количество выполняемых операций.</p>
</li>
<li>
<p>Создание индекса из словаря списков</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">for</span> page_index, page <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">enumerate</span>(pages):
    <span style="color: #007020; font-weight: bold">for</span> word <span style="color: #007020; font-weight: bold">in</span> page:
        d<span style="color: #666666">.</span>setdefault(word, [])<span style="color: #666666">.</span>append(page_index)
</code></pre></div>
<p>setdefault сомещает 2 поиска в одном (в отличии от get).</p>
</li>
</ul>
<p>Как видно из статистики, разработки интерпретатора рассмотрели множество 
вариантов в которых могут использоваться словари и постарались сделать 
максимально универсальную реализацию, оптимизации специфических случаев 
практически не делались.</p>
<p><strong>Внутренняя реализация в python 2.7</strong></p>
<p>Расматривается реализация словарей из python 2.7, потому что она достаточно 
проста для понимания и отличий от реализации в python 3.3 не так много.</p>
<p>Словарь это просто последовательная область памяти (массив). Для реализации
был выбран массив, потому что доступ к его элементам максимально быстрый.
В Си коде массив выглядит как массив содержаший струкртуры вида:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>typedef struct {
    Py_hash_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictKeyEntry;
</code></pre></div>
<p>Описание полей стуктуры:</p>
<ul>
<li>me_hash - хэш</li>
<li>*me_key - указатель на объект, который является ключом</li>
<li>*me_value - указатель на объект, который является значеним</li>
</ul>
<p>Легко прикинуть сколько данная структура занимает в места в пяти. Хэш занимает
32/64 бита (в зависимости от разрядности). То есть на 32 битной системе такая 
стуктура будет занимать 12 байт.</p>
<p>Новый словарь в памяти выглядит следующим образом</p>
<p><img alt="" src="python-notes-index/dict/impl-dict-in-cpython/1.jpg" /></p>
<blockquote>
<p><em>Колонка Idx явно не присутвует и нужна только для удобства восприятия.</em></p>
</blockquote>
<p>При инициадизации словаря (python 2.7 и 3.3) в нем сразу выделяется место для 8 
значений, это делается для оптимизации. Интересно отметить, что хоть место и
выделено для 8 значений, но 8 элементов в нем храниться не может (это будет 
объяснено далее).</p>
<p>В словаре в качестве ключа может выступать любой НЕ изменяемый объект (строка,
кортеж, frozen set и т д), в том чисте и кастомный объект в котором 
переопределен метод <code>__hash__</code>. </p>
<p><strong>Добавление нового элемента в словарь</strong></p>
<p>Для того, чтобы добавить новый элемент в словарь нужно преобразовать ключ в 
индекс массива (таблицы). Это делается следующим образом:</p>
<ul>
<li>ключ преобразововывается в число при помощи функции hash.</li>
<li>у полученного числа берется n младших бит </li>
</ul>
<p>Полученное значение и есть необходимый нам индекс массива.</p>
<blockquote>
<p>Особенность массива (таблицы) в том, что ее размер это всегда степень двойки, 
по этому n бит всегда будет валидным ключом, где n это степень двойки.</p>
</blockquote>
<p>Немного подробностей о работе функции hash.</p>
<p>Функция <code>hash</code> это просто builtin функция возвращающая 32/64 битное значение. 
Для вычисления возвращаемого значения используется системная функция, либо
метод <code>__hash__</code>, если он переопределен.</p>
<p>Генерируемый хеш должен обладать следующими свойствами:</p>
<ul>
<li>для одинаковых значений он всегда должен быть одинакомым</li>
<li>хеш должен быть один и тот же, даже если представления разные
типами (9, 9.0, complex(9,0))</li>
<li>похожие значения должны давать сильно отличающиеся хеши</li>
</ul>
<p>Теперь рассмотрим на примерах как происходит добавление новых элементов в 
словарь:</p>
<blockquote>
<p>Функция bits это не какая-то стандартная функция, она просто выводит
бинарное представление числа, в данном примере используется только для
визуализации.</p>
<p>Ещё необходимо понимать, что в действительности в таблице хранится указатель
на объект python`а, а не как изображено.</p>
</blockquote>
<details>
    <summary>Показать слайды</summary>

<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-1.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-2.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-3.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-4.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-5.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-6.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-7.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-8.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-9.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/add-new-element-10.jpg" />

</details>
<p>На данных слайдах изображен идеальный случай заполнения словаря, потому что
у нас не возникло коллизий (не было ситуаций, когда для разных значений
вычисленный хэш был одинаковым).</p>
<p><strong>Поиск значений в словаре</strong></p>
<p>На данный момент у нас есть заполненный словарь и мы хотим извлечь из него 
интересующие нас значения. Рассмотрим как это реализуется:</p>
<ul>
<li>сначала мы вычисляем хэш от ключа</li>
<li>обрезаем старшие биты</li>
<li>берем полученное значение и используем его как индекс для доступа к элементам
  массива</li>
</ul>
<p>Если визуализировать, то выглядит это следующим образом:</p>
<p><img alt="" src="python-notes-index/dict/impl-dict-in-cpython/search-element.jpg" /></p>
<p><strong>Перебор всех элементов словаря</strong></p>
<p>Получение всех элементов словаря: при итерировании, получение ключей <code>keys()</code> 
или получении значений <code>values()</code>, реализуется как последовательный перебор 
всех элементов таблицы, где пустые элементы пропускаются. Таким образом 
если распечатать словарь, то элементы в нем будут расположены в том порядке, в 
котором они лежат в памяти. Это совсем не тот порядок, в котором происходило 
добавление элементов в словарь.</p>
<details>
    <summary>Показать слайды</summary>

<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/print-dict-1.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/print-dict-2.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/print-dict-3.jpg" /> 

</details>
<p><strong>Коллизии</strong></p>
<p>Во всех предыдущих примерах, когда мы наблюдали за добавлением новых элементов
в словарь, рассматривался идеализированный случай, потому что при добавлении
новых элементов ни когда не возникало коллизий.</p>
<p>Коллизия - это ситуация, когда при вычислении индекса таблицы, для двух разных
ключей будет будет сгенерирован одинаковый индекс.</p>
<p>Примером может служить ситуация, когда хэш от двух разных ключей одинаковый. 
Причиной этого является особенность реализации функции <code>hash</code>, так как она 
расчиана на скорость, а не криптостойкость, а также то, что при вычислении 
индекса берется только n младших бит хэша.</p>
<p>Есть несколько способов как действовать при возникновении коллизии, в python 
используется метод "Открытой адресации". Его суть заключается в том, что после
возникновения коллизии мы находим в таблице первое свободное место после 
занятой ячейки и записываем элемент туда. Важно заметить, что вычисление 
индекса следующей свободной ячейки происходит не при помощи увеличения текущего
индекса на единицу. Как это делается будет рассмотрено позже, сейчас рассмотрим
как в общих чертах работает алгоритм "Открытой адресации".</p>
<details>
    <summary>Показать слайды</summary>

<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-1.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-2.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-3.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-4.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-5.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-6.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-7.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-8.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-9.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-10.jpg" />
<img alt="" src="python-notes-index/dict/impl-dict-in-cpython/collision-example-11.jpg" /> 

</details>
<p>На слайдах выше видно, как происходило добавление новых элементов, как 
разрешались коллизии (элементы, при добавлении которых произошла коллизия 
отмечены красным перечеркнутым равенством). Как можно заметить у элементов
при добавлении, которых произошла коллизия 3 младшие бита хэша не совпадают с
индексом ячейки в которой они хранится. Эта информация будет использоваться в
дальнешем при поиске элементов по ключу.</p>
<p><strong>Алгоритм поиска первой свободной ячейки</strong></p>
<p>Как говорилось ранее, алгоритм поиска первой свободной ячейки не просто 
увеличивает текущий индекс на единицу. Это связано с тем, что последовательный
поиск очень не оптимален, если ключами словаря служат числа. Дело в том, что 
хэш от числа это само число (если число больше 32 битов, на 32 битной системе,
то просто отбрасываются старшие биты). А на практике довольно часто 
встречаются словари, в которых ключи это последовательные числа. Соотвественно,
если бы алгоритм поиска свободной ячейки просто увеличивал индекс на единицу,
то при добавлении в такой словарь нового элемента, ключ у которого строка 
и ее хэш попадал бы на начало последовательности, то нам бы пришлось 
пройти всю таблицу, чтобы найти первую свободную ячейку.</p>
<p>Для того, чтобы избежать такой ситуации была выбран следующий алгоритм:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020"># pertrurb нужен для того, чтобы сделать генерируемое значение более случайным</span>
pertrurb<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>hash<span style="color: #bbbbbb"></span>
<span style="color: #007020; font-weight: bold">while</span><span style="color: #bbbbbb"> </span>(<span style="color: #666666">&lt;</span>слот<span style="color: #bbbbbb"> </span>занят<span style="color: #666666">&gt;</span>)<span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span>perturb<span style="color: #bbbbbb"> </span><span style="color: #666666">&gt;&gt;=</span><span style="color: #bbbbbb"> </span><span style="color: #40a070">5</span>;<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span><span style="color: #007020"># slot хранит предыдущие значение</span>
<span style="color: #bbbbbb">    </span>slot<span style="color: #bbbbbb"> </span><span style="color: #666666">=</span><span style="color: #bbbbbb"> </span>(<span style="color: #40a070">5</span><span style="color: #bbbbbb"> </span><span style="color: #666666">*</span><span style="color: #bbbbbb"> </span>slot)<span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span><span style="color: #40a070">1</span><span style="color: #bbbbbb"> </span><span style="color: #666666">+</span><span style="color: #bbbbbb"> </span>perturb;<span style="color: #bbbbbb"></span>
}<span style="color: #bbbbbb"></span>
</code></pre></div>
<p>Если вызывать данный аглоритм 2 в 32 степени раз, то он сгенерирует 
последвательность всех int`отв, только они будут не отсортированы.</p>
<p><strong>Получение значений по ключу</strong></p>
<p>Пример получения значения по ключу, простой случай:</p>
<p><img alt="" src="python-notes-index/dict/impl-dict-in-cpython/get-value-by-key-1.jpg" /></p>
<p>В простом случае получение значения по ключу происходит по стандароному 
алгоритму:</p>
<ul>
<li>считаем хэш от ключа</li>
<li>берем от хэша n младших битов</li>
<li>полученое значение используем как индекс</li>
<li>готово, нужное значение получили</li>
</ul>
<p>В сложном случае мы можем столкнуться с коллизией:</p>
<p><img alt="" src="python-notes-index/dict/impl-dict-in-cpython/get-value-by-key-2.jpg" /></p>
<p>В этом случае алгоритм будет следующий:</p>
<ul>
<li>считаем хэш от ключа</li>
<li>берем от хэша n младших битов</li>
<li>полученое значение используем как индекс</li>
</ul>
<p>TODO дописать https://www.youtube.com/watch?v=JhixzgVpmdM 20:55 </p>
<blockquote>
<p>Данная заметка основана на докладе Кирилла Лашкевича 
<a href="https://www.youtube.com/watch?v=JhixzgVpmdM">Dictionary в Python. Кирилл Лашкевич - Python Meetup 30.08.2013</a>, (<a href="https://cloud.mail.ru/public/3ph9/3LvBrTk5o">Локальная копия</a>)</p>
</blockquote>
<p>Материалы по данной теме:</p>
<ul>
<li><a href="http://qaru.site/questions/23060/how-are-pythons-built-in-dictionaries-implemented">Как реализован Python в словарях | qaru</a></li>
<li><a href="http://www.rupython.com/147-147.html">Как реализованы встроенные словари python | rupython</a></li>
</ul>
<blockquote>
<p>Python 3.6 и выше</p>
</blockquote>
<p>Начиная с python 3.6 реализация словарей была изменена. Давайте рассмотрим 
реализаю современных словарей.</p>
<p>До версии 3.6 все данные хранились в одном достаточно сильно разряженом 
массиве (прочитать деталии реализации можно в начале статьи), а начиная с 
версии 3.6 для хранения данных решено было использовать 2 массива:</p>
<ul>
<li>первый массив хранит указатели на стуктуры <code>PyDictKeyEntry</code>
    <div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">typedef</span><span style="color: #bbbbbb"> </span><span style="color: #007020; font-weight: bold">struct</span><span style="color: #bbbbbb"> </span>{<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span>Py_hash_t<span style="color: #bbbbbb"> </span>me_hash;<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span>PyObject<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>me_key;<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">    </span>PyObject<span style="color: #bbbbbb"> </span><span style="color: #666666">*</span>me_value;<span style="color: #bbbbbb"></span>
}<span style="color: #bbbbbb"> </span>PyDictKeyEntry;<span style="color: #bbbbbb"></span>
</code></pre></div>
  Стоит заметить, что элементы в данном массиве хранятся в порядке их 
  добавления и записываются последовательно (в массиве отсуствуют пустосты);</li>
<li>второй массив хранит индексы указывающие на данные из первого массива. Данный
  массив уже имеет разряженную структуру (как в изначальной реализации).</li>
</ul>
<p>Рассмотрим пример написанный на python. Для визуализации возьмем следующий 
словарь:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>d <span style="color: #666666">=</span> {<span style="color: #4070a0">&#39;timmy&#39;</span>: <span style="color: #4070a0">&#39;red&#39;</span>, <span style="color: #4070a0">&#39;barry&#39;</span>: <span style="color: #4070a0">&#39;green&#39;</span>, <span style="color: #4070a0">&#39;guido&#39;</span>: <span style="color: #4070a0">&#39;blue&#39;</span>}
</code></pre></div>
<p>До версии 3.6 данные такого словаря хранились вот так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>entries <span style="color: #666666">=</span> [[<span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>],
           [<span style="color: #666666">-</span><span style="color: #40a070">8522787127447073495</span>, <span style="color: #4070a0">&#39;barry&#39;</span>, <span style="color: #4070a0">&#39;green&#39;</span>],
           [<span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>],
           [<span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>],
           [<span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>],
           [<span style="color: #666666">-</span><span style="color: #40a070">9092791511155847987</span>, <span style="color: #4070a0">&#39;timmy&#39;</span>, <span style="color: #4070a0">&#39;red&#39;</span>],
           [<span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>, <span style="color: #4070a0">&#39;--&#39;</span>],
           [<span style="color: #666666">-</span><span style="color: #40a070">6480567542315338377</span>, <span style="color: #4070a0">&#39;guido&#39;</span>, <span style="color: #4070a0">&#39;blue&#39;</span>]]
</code></pre></div>
<p>А начиная с версии 3.6 и выше:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>indices <span style="color: #666666">=</span>  [<span style="color: #007020; font-weight: bold">None</span>, <span style="color: #40a070">1</span>, <span style="color: #007020; font-weight: bold">None</span>, <span style="color: #007020; font-weight: bold">None</span>, <span style="color: #007020; font-weight: bold">None</span>, <span style="color: #40a070">0</span>, <span style="color: #007020; font-weight: bold">None</span>, <span style="color: #40a070">2</span>]
entries <span style="color: #666666">=</span>  [[<span style="color: #666666">-</span><span style="color: #40a070">9092791511155847987</span>, <span style="color: #4070a0">&#39;timmy&#39;</span>, <span style="color: #4070a0">&#39;red&#39;</span>],
            [<span style="color: #666666">-</span><span style="color: #40a070">8522787127447073495</span>, <span style="color: #4070a0">&#39;barry&#39;</span>, <span style="color: #4070a0">&#39;green&#39;</span>],
            [<span style="color: #666666">-</span><span style="color: #40a070">6480567542315338377</span>, <span style="color: #4070a0">&#39;guido&#39;</span>, <span style="color: #4070a0">&#39;blue&#39;</span>]]
</code></pre></div>
<p>Как мы видим из данного примера изменился только способ хранения данных и он 
ни как не влияет на алгоритмы работы заложеные в раннюю реализацию словарей.</p>
<p>Материалы по данной теме:</p>
<ul>
<li><a href="http://pythonz.net/videos/95/">Современные словари в python: сочетание дюжины отличных идей. Реймонд Хеттинджер - PyCon 2017</a>, <a href="https://cloud.mail.ru/public/3DTb/3RiKYo5c2">Копия доклада</a></li>
<li><a href="python-notes-index/dict/impl-dict-in-cpython/impl-compact-and-ordered-dict.py">Реализация словарей из python &gt;= 3.6 написанная на python</a> - 
  код из презентации Реймонда Хеттинджера</li>
<li><a href="http://code.activestate.com/recipes/578375/">Proof-of-concept for a more space-efficient, faster-looping dictionary</a></li>
<li><a href="https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html">Faster, more memory efficient and more ordered dictionaries on PyPy</a></li>
<li><a href="https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6">Are dictionaries ordered in Python 3.6+? | StackOverflow</a></li>
<li><a href="https://m.habr.com/ru/company/otus/blog/448350/">Реализация словаря в Python - habr</a></li>
<li><a href="https://habr.com/ru/post/432996/">Немного внутренностей словарей в CPython (и PyPy)</a>, <a href="https://cloud.mail.ru/public/5J7t/2tUtjwNpD">копия</a></li>
</ul>
<p><a name='Файлы'></a></p>
<h3>Файлы</h3>
<p><a name='Кодировка-файла'></a></p>
<h4>Кодировка файла</h4>
<p>При открытие файла лучше всего всегда явно указывать его кодировку. 
В python3 это делается это вот-так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>file <span style="color: #666666">=</span> <span style="color: #007020">open</span>(<span style="color: #4070a0">&#39;Титульник.txt&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #4070a0">&#39;utf-8&#39;</span>)
</code></pre></div>
<p>В python2, нужно использовать функцию open из модуля codecs:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">codecs</span>
codecs<span style="color: #666666">.</span>open(<span style="color: #4070a0">&#39;Титульник.txt&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #4070a0">&#39;utf-8&#39;</span>)
</code></pre></div>
<p>Чтобы работать с файлом в кодировке utf8-bom, его нужно открывать 
следующим образом:</p>
<p>python3</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>inp <span style="color: #666666">=</span> <span style="color: #007020">open</span>(<span style="color: #4070a0">&#39;test&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #4070a0">&#39;utf-8-sig&#39;</span>)
</code></pre></div>
<p>python2
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">codecs</span>
inp <span style="color: #666666">=</span> codecs<span style="color: #666666">.</span>open(<span style="color: #4070a0">&#39;test&#39;</span>, encoding<span style="color: #666666">=</span><span style="color: #4070a0">&#39;utf-8-sig&#39;</span>)
</code></pre></div></p>
<p><a name='Работа-с-большими-файлами'></a></p>
<h4>Работа с большими файлами</h4>
<p>Правильный подход при работе с большими файлами состоит в том, чтобы не 
загружать в память файл за раз целиком (например методом <code>readlines()</code>), а 
считывать файл постепенно:</p>
<ul>
<li><code>read(n)</code> позволяет считать заданное количество байт из файла;</li>
<li><code>readline()</code> считывает за раз только одну строку из файла;</li>
<li>так-же можно использовать протокол итераторов.</li>
</ul>
<p>В python протоколом итераций называют такое поведение, когда объект реализует 
метод <code>__next__</code> который возврщает при вызове следующие значение, а когда 
объекты кончились возбуждает исключение <code>Stoplteration</code>.
Файлы поддерживают итерационный протокол (имееют метод <code>__next__</code>), по этому 
правильным вариантом работы с ними будет использование цикла for, так как он 
при своей работе вызывает метод объекта <code>__next__</code>, так же он сам перехватывает 
исключение <code>Stoplteration</code>.</p>
<p>Пример:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">for</span> line <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">open</span>(<span style="color: #4070a0">&#39;file.txt&#39;</span>):
    <span style="color: #007020">print</span>(line<span style="color: #666666">.</span>upper())
</code></pre></div>
<p>Метод <code>__next__</code> можно вызывать и ручную используя цикл <code>while</code>, но в этом 
случае нужно в ручную перехватывать исключение <code>StopIteration</code>.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>inp <span style="color: #666666">=</span> <span style="color: #007020">open</span>(<span style="color: #4070a0">&#39;out&#39;</span>)
<span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
    <span style="color: #007020; font-weight: bold">try</span>:
        <span style="color: #007020">print</span>(inp<span style="color: #666666">.</span><span style="color: #06287e">__next__</span>())
    <span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">StopIteration</span>:
        <span style="color: #007020; font-weight: bold">break</span>
</code></pre></div>
<p><a name='Изменение-прав-доступа,-владельца'></a></p>
<h4>Изменение прав доступа, владельца</h4>
<p><strong>Изменение прав доступа</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">os</span>
script_update <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;/home/alex/update.sh&#39;</span>
os<span style="color: #666666">.</span>chmod(path<span style="color: #666666">=</span>script_update, mode<span style="color: #666666">=</span><span style="color: #007020">int</span>(<span style="color: #4070a0">&#39;700&#39;</span>, base<span style="color: #666666">=</span><span style="color: #40a070">8</span>))
</code></pre></div>
<p>Агрумент mode принимает значение в восьмеричном формате, по этому десятиричное 
представление нужно преобразовывать, перед передачей функции.</p>
<p><strong>Изменение владельца</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">os</span>
script_update <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;/home/alex/update.sh&#39;</span>
os<span style="color: #666666">.</span>chmod(path<span style="color: #666666">=</span>script_update, mode<span style="color: #666666">=</span><span style="color: #007020">int</span>(<span style="color: #4070a0">&#39;700&#39;</span>, base<span style="color: #666666">=</span><span style="color: #40a070">8</span>))
</code></pre></div>
<p><a name='Разбиение-файла-на-несколько-генераторов'></a></p>
<h4>Разбиение файла на несколько генераторов</h4>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">math</span>
<span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">itertools</span>

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">openfile</span>(filename):
   <span style="color: #007020; font-weight: bold">with</span> <span style="color: #007020">open</span>(filename) <span style="color: #007020; font-weight: bold">as</span> file_:
       <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> file_:
           <span style="color: #007020; font-weight: bold">yield</span> i<span style="color: #666666">.</span>strip()

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">file_split</span>(filename, parts):
   <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">   Разбивает содержимое файла на несколько итераторов</span>
<span style="color: #4070a0; font-style: italic">   &quot;&quot;&quot;</span>
   all_str <span style="color: #666666">=</span> <span style="color: #007020">sum</span>(<span style="color: #40a070">1</span> <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">open</span>(filename, <span style="color: #4070a0">&#39;r&#39;</span>))  <span style="color: #60a0b0; font-style: italic"># кол-во строк в файле</span>
   count <span style="color: #666666">=</span> math<span style="color: #666666">.</span>ceil(all_str <span style="color: #666666">/</span> parts)  <span style="color: #60a0b0; font-style: italic"># размер среза</span>

   offset <span style="color: #666666">=</span> <span style="color: #40a070">0</span>
   chunks <span style="color: #666666">=</span> []  <span style="color: #60a0b0; font-style: italic"># Итераторы содержащие разные части файла</span>
   <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(parts):
       file_ <span style="color: #666666">=</span> openfile(filename)
       chunks<span style="color: #666666">.</span>append((itertools<span style="color: #666666">.</span>islice(file_, offset, offset <span style="color: #666666">+</span> count)))
       offset <span style="color: #666666">+=</span> count

   <span style="color: #007020; font-weight: bold">return</span> chunks
</code></pre></div>
<p><a name='Функции-раздел'></a></p>
<h2>Функции</h2>
<p><a name='Стандартные-функции'></a></p>
<h3>Стандартные функции</h3>
<p><a name='Попарное-объединение-элементов-итерируемых-объектов'></a></p>
<h4>Попарное объединение элементов итерируемых объектов</h4>
<p>Из двух (или более) итерируемых последовательностей можно создать один список, 
содержащий кортежи из пар элементов этих последовательностей, а недостающие 
будут заменены None.</p>
<p>В python2, для этого можно использовать стандартную функцию map:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">map</span>(<span style="color: #007020; font-weight: bold">None</span>, [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>], [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>]) 
[(<span style="color: #40a070">1</span>, <span style="color: #40a070">1</span>), (<span style="color: #40a070">2</span>, <span style="color: #40a070">2</span>), (<span style="color: #40a070">3</span>, <span style="color: #007020; font-weight: bold">None</span>)]
</code></pre></div>
<p>В python3, нужно использовать функцию zip_longest из модуля itertools:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">itertools</span> <span style="color: #007020; font-weight: bold">import</span> zip_longest
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">list</span>(zip_longest([<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>], [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>], fillvalue<span style="color: #666666">=</span><span style="color: #007020; font-weight: bold">None</span>))
[(<span style="color: #40a070">1</span>, <span style="color: #40a070">1</span>), (<span style="color: #40a070">2</span>, <span style="color: #40a070">2</span>), (<span style="color: #40a070">3</span>, <span style="color: #007020; font-weight: bold">None</span>)]
</code></pre></div>
<p><a name='Перевод-из-одной-системы-счисления-в-другую-с-помощью-int()'></a></p>
<h4>Перевод из одной системы счисления в другую с помощью int()</h4>
<p>В Python, чтобы перевести число из одной системы счисления в другую не нужно 
городить свои велосипеды, можно воспользоваться встроенной функцией int.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">int</span>(<span style="color: #4070a0">&quot;AF&quot;</span>, <span style="color: #40a070">16</span>)
<span style="color: #40a070">175</span> 
</code></pre></div>
<p>В этом примере мы перевели шестнадцатиричное число в десятичную систему 
счисления. Для этого мы в качестве 1 аргумента передали в виде строки число 
в шестнадцатеричной системе счисления и 2 аргументом передали основание 
системы счисления (Основание системы счисления, показывает сколько цифр и 
символов применяется для изображения числа. Например в десятичной системе 
счисления, основание будет 10.).</p>
<p><a name='Функция-len'></a></p>
<h4>len</h4>
<p>len - возвращает число элементов в указанном объекте-контейнере.</p>
<p>Для того, чтобы данная функция могла работать с экземлярами классов, которые 
разработали вы сами, необходимо реализовать в них метод <code>__len__</code>.</p>
<blockquote>
<p>При работе со встроенными типами данных (str, list, bytearray) len возвращает 
значение поля <code>ob_size</code> C-структуры <code>PyVarObject</code>, которая представляет в 
памяти любой встроенный объект. Благодя такой реализации, функция <code>len</code> очень
быстро работает со встроенными типами, так как обращение к полю тратит меньше 
ресурсов, чем вызов метода.</p>
</blockquote>
<p><a name='Функция-map'></a></p>
<h4>map</h4>
<p>Функция map применяет функцию к каждому элементу последовательности и возвращает итератор с результатами.</p>
<p>Например, с помощью map можно выполнять преобразования элементов. Перевести все строки в верхний регистр:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> list_of_words <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;one&#39;</span>, <span style="color: #4070a0">&#39;two&#39;</span>, <span style="color: #4070a0">&#39;list&#39;</span>, <span style="color: #4070a0">&#39;&#39;</span>, <span style="color: #4070a0">&#39;dict&#39;</span>]
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">map</span>(<span style="color: #007020">str</span><span style="color: #666666">.</span>upper, list_of_words)
<span style="color: #666666">&lt;</span><span style="color: #007020">map</span> <span style="color: #007020">object</span> at <span style="color: #40a070">0x102378760</span><span style="color: #666666">&gt;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">list</span>(<span style="color: #007020">map</span>(<span style="color: #007020">str</span><span style="color: #666666">.</span>upper, list_of_words))
[<span style="color: #4070a0">&#39;ONE&#39;</span>, <span style="color: #4070a0">&#39;TWO&#39;</span>, <span style="color: #4070a0">&#39;LIST&#39;</span>, <span style="color: #4070a0">&#39;&#39;</span>, <span style="color: #4070a0">&#39;DICT&#39;</span>]
</code></pre></div>
<p><strong>Производительность</strong></p>
<p>Функция map работает в некоторых случаях немного быстрее чем list comprehensions:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>alex@macbook PycharmProjects % python3 -m timeit -u nsec -s<span style="color: #4070a0">&#39;xs=range(10)&#39;</span> <span style="color: #4070a0">&#39;list(map(hex, xs))&#39;</span>
<span style="color: #40a070">1000000</span> loops, best of <span style="color: #40a070">5</span>: <span style="color: #40a070">404</span> nsec per loop
alex@macbook PycharmProjects % python3 -m timeit -u nsec -s<span style="color: #4070a0">&#39;xs=range(10)&#39;</span> <span style="color: #4070a0">&#39;[hex(x) for x in xs]&#39;</span>
<span style="color: #40a070">500000</span> loops, best of <span style="color: #40a070">5</span>: <span style="color: #40a070">533</span> nsec per loop
</code></pre></div>
<p>Но не в том случае, если для преобразования последовательности применяется lambda:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>alex@macbook PycharmProjects % python3 -m timeit -u nsec -s<span style="color: #4070a0">&#39;xs=range(10)&#39;</span> <span style="color: #4070a0">&#39;list(map(lambda x: x+2, xs))&#39;</span>
<span style="color: #40a070">500000</span> loops, best of <span style="color: #40a070">5</span>: <span style="color: #40a070">557</span> nsec per loop
alex@macbook PycharmProjects % python3 -m timeit -u nsec -s<span style="color: #4070a0">&#39;xs=range(10)&#39;</span> <span style="color: #4070a0">&#39;[x+2 for x in xs]&#39;</span>
<span style="color: #40a070">1000000</span> loops, best of <span style="color: #40a070">5</span>: <span style="color: #40a070">350</span> nsec per loop
</code></pre></div>
<p>P.S. Данные тесты производились на Python 3.9.7, на macbook pro 13 c m1.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://stackoverflow.com/a/1247490">List comprehension vs map - stackoverflow</a></li>
</ul>
<p><a name='Функции'></a></p>
<h3>Функции</h3>
<p><a name='Особенности-использования-lambda-в-цикле'></a></p>
<h4>Особенности использования lambda в цикле</h4>
<p>В цикле анонимные функции нужно использовать с осторожностью, потому что 
они «ленивые». По другому это называется отложенные вычисления. </p>
<blockquote>
<p>Отложенные вычисления (англ. lazy evaluation, также ленивые вычисления или 
нестрогие вычисления) — технология, которая позволяет вам отсрочить 
вычисление кода до тех пор, пока не понадобится получить результат 
вычислений.</p>
</blockquote>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>args <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>]
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> args:
    func <span style="color: #666666">=</span> <span style="color: #007020; font-weight: bold">lambda</span> x: x <span style="color: #666666">+</span> i  <span style="color: #60a0b0; font-style: italic"># 3</span>
    <span style="color: #007020">print</span>(func(<span style="color: #40a070">0</span>))  <span style="color: #60a0b0; font-style: italic"># 4</span>

funcs <span style="color: #666666">=</span> []
<span style="color: #007020; font-weight: bold">for</span> j <span style="color: #007020; font-weight: bold">in</span> args:
    funcs<span style="color: #666666">.</span>append(<span style="color: #007020; font-weight: bold">lambda</span> x: x <span style="color: #666666">+</span> j)
<span style="color: #007020; font-weight: bold">for</span> f <span style="color: #007020; font-weight: bold">in</span> funcs:  <span style="color: #60a0b0; font-style: italic"># 9</span>
    <span style="color: #007020">print</span>(f(<span style="color: #40a070">0</span>))
</code></pre></div>
<p>Пояснения:</p>
<ul>
<li>3 определили функцию, но пока мы ее не вызовем, переменные внутри функции 
не будут инициализированны;</li>
<li>4 тут все ожидаемо, тело функции было инициализированно с текущим значением i;</li>
<li>9 в этом цикле при вызове любой функции будет выведено число 3. Это 
получается потому, что инициализация lambda функции происходит при её вызове 
(это как раз и есть ленивые вычисления, вычисления происходят только тогда, 
когда это требуется) и при вызове функции перменная j == 3 .</li>
</ul>
<p><strong>Вывод</strong></p>
<p>Анонимные функции инициализируется непосредственно в момент их вызова и если 
значение переменной которая в неё передавалась изменилось, то функция будет 
инициализированна с тем значением которое в ней записано на момент вызова, а 
не с тем, какое передавалось в функцию при создании. В приведённом примере 
выход из цикла происходит, когда j == 3 и получается, что во всех созданных 
функциях j будет равно 3.</p>
<p><strong>Решение сложившейся проблемы</strong></p>
<p>Описанную выше проблему можно избежать если изменить код и сделать все так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>funcs <span style="color: #666666">=</span> []
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">1</span>, <span style="color: #40a070">4</span>):
   funcs<span style="color: #666666">.</span>append(<span style="color: #007020; font-weight: bold">lambda</span> arg1, arg2<span style="color: #666666">=</span>i: arg1 <span style="color: #666666">+</span> arg2)
<span style="color: #007020; font-weight: bold">for</span> f <span style="color: #007020; font-weight: bold">in</span> funcs:
   <span style="color: #007020">print</span>(f(<span style="color: #40a070">1</span>))
</code></pre></div>
<p><a name='Замыкание'></a></p>
<h4>Замыкание</h4>
<p>Замыкание (англ. closure) — функция первого класса, в теле которой присутствуют
ссылки на переменные, объявленные вне тела этой функции в окружающем коде и 
не являющиеся её параметрами.</p>
<p>Замыкание, также как и экземпляр класса, есть способ представления 
функциональности и данных, связанных и упакованных вместе.</p>
<p>В жизни то, что описано выше выглядит следующим образом:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">foo</span>(a):
<span style="color: #666666">...</span>     <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">bar</span>(b):
<span style="color: #666666">...</span>         <span style="color: #007020; font-weight: bold">return</span> b <span style="color: #666666">*</span> a 
<span style="color: #666666">...</span>     <span style="color: #007020; font-weight: bold">return</span> bar
<span style="color: #666666">...</span> 
<span style="color: #666666">&gt;&gt;&gt;</span> bar <span style="color: #666666">=</span> foo(<span style="color: #40a070">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> bar(<span style="color: #40a070">5</span>)
<span style="color: #40a070">10</span>
<span style="color: #666666">&gt;&gt;&gt;</span> bar(<span style="color: #40a070">10</span>)
<span style="color: #40a070">20</span>
</code></pre></div>
<p>Как мы видим, функция bar может получать доступ к переменным из области 
видимости foo, это и называется замыканием.</p>
<p><a name='Сопрограммы'></a></p>
<h3>Сопрограммы</h3>
<p><a name='yield-from'></a></p>
<h4>yield from</h4>
<p>yield from можно рассматривать с 2 сторон:</p>
<ol>
<li>
<p>Это синтаксический сахар</p>
<p>Реализация без yield from</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">generator</span>():
    <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">10</span>):
        <span style="color: #007020; font-weight: bold">yield</span> i

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>():
    <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> generator():
        <span style="color: #007020; font-weight: bold">yield</span> i

<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> wrapper():
    <span style="color: #007020">print</span>(i)
</code></pre></div>
<p>Реализация c и спользованием yield from</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">generator</span>():
    <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">10</span>):
        <span style="color: #007020; font-weight: bold">yield</span> i

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>():
    <span style="color: #007020; font-weight: bold">yield from</span> generator()

<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> wrapper():
    <span style="color: #007020">print</span>(i)
</code></pre></div>
</li>
<li>
<p>yield from обеспечивает прозрачный двусторонний канал от вызывающего до 
субгенератора. Это включает получение данных из и отправку данных 
в субгенератор.</p>
</li>
</ol>
<p><strong>Чтение данных из генератора используя yield from</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">reader</span>():
    <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">    Генератор, который создает видимость чтения из файла, сокета и т д</span>
<span style="color: #4070a0; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">4</span>):
        <span style="color: #007020; font-weight: bold">yield</span> <span style="color: #4070a0">&#39;&lt;&lt; </span><span style="color: #70a0d0; font-style: italic">%s</span><span style="color: #4070a0">&#39;</span> <span style="color: #666666">%</span> i

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">reader_wrapper</span>(g):
    <span style="color: #60a0b0; font-style: italic"># Ручной обход данных произведенных reader</span>
    <span style="color: #007020; font-weight: bold">for</span> v <span style="color: #007020; font-weight: bold">in</span> g:
        <span style="color: #007020; font-weight: bold">yield</span> v

wrap <span style="color: #666666">=</span> reader_wrapper(reader())
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> wrap:
    <span style="color: #007020">print</span>(i)
<span style="color: #60a0b0; font-style: italic"># Result</span>
<span style="color: #666666">&lt;&lt;</span> <span style="color: #40a070">0</span>
<span style="color: #666666">&lt;&lt;</span> <span style="color: #40a070">1</span>
<span style="color: #666666">&lt;&lt;</span> <span style="color: #40a070">2</span>
<span style="color: #666666">&lt;&lt;</span> <span style="color: #40a070">3</span>
</code></pre></div>
<p>Вместо ручного обхода данных reader() мы можем просто использовать yield from.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">reader_wrapper</span>(g):
    <span style="color: #007020; font-weight: bold">yield from</span> g
</code></pre></div>
<p>Это работает и мы избавились от 1 строки кода.</p>
<p><strong>Отправка данных в генератор (сопрограмма) используя yield from. Часть 1.</strong></p>
<p>Сейчас давайте сделаем, что-нибудь более интересное. Создадим сопрограмму 
вызывающую <code>writer</code>, который принимает данные и отправляет их в сокет, 
файловый дескриптор и т д.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer</span>():
    <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">    Сопрограмма, которая записывает данные в сокет, файловый дескриптор и т д</span>
<span style="color: #4070a0; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
        w <span style="color: #666666">=</span> (<span style="color: #007020; font-weight: bold">yield</span>)
        <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;&gt;&gt; &#39;</span>, w)
</code></pre></div>
<p>Теперь главный вопрос как должна выглядеть функция wrapper обрабатывающая 
отправку данных writer, так чтобы любые данные прозрачно передавались от 
<code>wrapper</code> к <code>writer()</code>.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer_wrapper</span>(coro):
    <span style="color: #60a0b0; font-style: italic"># Будет описана позже</span>
    <span style="color: #007020; font-weight: bold">pass</span>

w <span style="color: #666666">=</span> writer()
wrap <span style="color: #666666">=</span> writer_wrapper(w)
wrap<span style="color: #666666">.</span>send(<span style="color: #007020; font-weight: bold">None</span>)  <span style="color: #60a0b0; font-style: italic"># &quot;prime&quot; the coroutine</span>
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">4</span>):
    wrap<span style="color: #666666">.</span>send(i)

<span style="color: #60a0b0; font-style: italic"># Ожидаемый результат</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">0</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">1</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">2</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">3</span>
</code></pre></div>
<p>Wrapper должен принять отправленные ему данные и так же должен обработать 
<code>StopIteration</code>, когда цикл <code>for</code> будет завершен. Очевидно, что просто написать</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">for</span> x <span style="color: #007020; font-weight: bold">in</span> coro: 
    <span style="color: #007020; font-weight: bold">yield</span> x
</code></pre></div>
<p>не получится.</p>
<p>Вот версия, которая работает:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer_wrapper</span>(coro):
    coro<span style="color: #666666">.</span>send(<span style="color: #007020; font-weight: bold">None</span>)  <span style="color: #60a0b0; font-style: italic"># prime the coro</span>
    <span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
        <span style="color: #007020; font-weight: bold">try</span>:
            x <span style="color: #666666">=</span> (<span style="color: #007020; font-weight: bold">yield</span>)  <span style="color: #60a0b0; font-style: italic"># Получаем значение, которое будем отправлять</span>
            coro<span style="color: #666666">.</span>send(x)  <span style="color: #60a0b0; font-style: italic"># передаем его для writer</span>
        <span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">StopIteration</span>:
            <span style="color: #007020; font-weight: bold">pass</span>
</code></pre></div>
<p>Или вместо этого мы можем написать это:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer_wrapper</span>(coro):
    <span style="color: #007020; font-weight: bold">yield from</span> coro
</code></pre></div>
<p>Так мы сохраним 6 строчек кода, сделаем код более читаемым и это 
просто работает. Магия!</p>
<p><strong>Отправка данных в генератор (сопрограмма) используя yield from. Часть 2. 
Обработка ошибок.</strong></p>
<p>Давайте сделаем предыдущий пример немного сложнее. Что если нашему writer нужно 
обрабатывать исключения? Давайте скажем <code>writer</code> обрабатывать <code>SpamException</code> и 
выводить ***, если оно произошло.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">SpamException</span>(<span style="color: #007020">Exception</span>):
    <span style="color: #007020; font-weight: bold">pass</span>

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer</span>():
    <span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
        <span style="color: #007020; font-weight: bold">try</span>:
            w <span style="color: #666666">=</span> (<span style="color: #007020; font-weight: bold">yield</span>)
        <span style="color: #007020; font-weight: bold">except</span> SpamException:
            <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;***&#39;</span>)
        <span style="color: #007020; font-weight: bold">else</span>:
            <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;&gt;&gt; &#39;</span>, w)
</code></pre></div>
<p>Что если не менять <code>writer_wrapper</code>? Будет это работать? Давайте проверим!</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #60a0b0; font-style: italic"># writer_wrapper такой как выше (длинная версия)</span>
w <span style="color: #666666">=</span> writer()
wrap <span style="color: #666666">=</span> writer_wrapper(w)
wrap<span style="color: #666666">.</span>send(<span style="color: #007020; font-weight: bold">None</span>)  <span style="color: #60a0b0; font-style: italic"># &quot;prime&quot; the coroutine</span>

<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> [<span style="color: #40a070">0</span>, <span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #4070a0">&#39;spam&#39;</span>, <span style="color: #40a070">4</span>]:
    <span style="color: #007020; font-weight: bold">if</span> i <span style="color: #666666">==</span> <span style="color: #4070a0">&#39;spam&#39;</span>:
        wrap<span style="color: #666666">.</span>throw(SpamException)
    <span style="color: #007020; font-weight: bold">else</span>:
        wrap<span style="color: #666666">.</span>send(i)


<span style="color: #60a0b0; font-style: italic"># Ожидаемый результат</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">0</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">1</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">2</span>
<span style="color: #666666">***</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">4</span>

<span style="color: #60a0b0; font-style: italic"># Полученный результат</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">0</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">1</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">2</span>
Traceback (most recent call last):
  <span style="color: #666666">...</span> redacted <span style="color: #666666">...</span>
  File <span style="color: #666666">...</span> <span style="color: #007020; font-weight: bold">in</span> writer_wrapper
    x <span style="color: #666666">=</span> (<span style="color: #007020; font-weight: bold">yield</span>)
__main__<span style="color: #666666">.</span>SpamException
</code></pre></div>
<p>Не работает, потому что x = (yield) просто возбуждает ошибку и вся программа 
аварийно завершается. Давайте заставим программу работать, будем ловить 
исключения в <code>writer_wrapper</code> и вручную кидать их в суб-генератор (<code>writer</code>), 
а если ошибки не возникает просто передавать значения в суб-генератор.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer_wrapper</span>(coro):
    <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;Works. Manually catches exceptions and throws them&quot;&quot;&quot;</span>
    coro<span style="color: #666666">.</span>send(<span style="color: #007020; font-weight: bold">None</span>)  <span style="color: #60a0b0; font-style: italic"># prime the coro</span>
    <span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
        <span style="color: #007020; font-weight: bold">try</span>:
            <span style="color: #007020; font-weight: bold">try</span>:
                x <span style="color: #666666">=</span> (<span style="color: #007020; font-weight: bold">yield</span>)
            <span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">Exception</span> <span style="color: #007020; font-weight: bold">as</span> e:   <span style="color: #60a0b0; font-style: italic"># This catches the SpamException</span>
                coro<span style="color: #666666">.</span>throw(e)
            <span style="color: #007020; font-weight: bold">else</span>:
                coro<span style="color: #666666">.</span>send(x)
        <span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">StopIteration</span>:
            <span style="color: #007020; font-weight: bold">pass</span>
</code></pre></div>
<p>Это работает.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #60a0b0; font-style: italic"># Результат</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">0</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">1</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">2</span>
<span style="color: #666666">***</span>
<span style="color: #666666">&gt;&gt;</span>  <span style="color: #40a070">4</span>
</code></pre></div>
<p>Но и это тоже!</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">writer_wrapper</span>(coro):
    <span style="color: #007020; font-weight: bold">yield from</span> coro
</code></pre></div>
<p><code>yield from</code> прозрачно обрабатывает отправку значений или кидает исключения 
внутрь суб-генератора.</p>
<p>Хотя это все равно не покрывает все возможные случаи. Что случиться если 
генератор будет закрыт (возникает <code>StopItaration</code>)? Что о том случае, если 
суб-генератор возвращает значение (в python 3 генератор может возвращать 
значение), как оно будет возвращаться? Все случаи, которые может обработать 
<code>yield</code> from описаны в PEP 380.</p>
<p>Ссылки:
- <a href="http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3">Оригинальная статья</a>
- <a href="http://legacy.python.org/dev/peps/pep-0380/">PEP 380 - Syntax for delegating to a sub-generator</a>
- <a href="http://legacy.python.org/dev/peps/pep-0342/">PEP 342 - Coroutines via Enhanced Generators</a>
- <a href="http://dabeaz.com/coroutines/">Dave Beazley's Curious Course on Couroutines</a> 
данная статья великолепна для начала. 
<a href="http://dabeaz.com/coroutines/Coroutines.pdf">Посмотрите слайды 24-33</a> чтобы 
увидеть наглядные примеры.</p>
<p><a name='Классы'></a></p>
<h2>Классы</h2>
<p><a name='Объектная-модель'></a></p>
<h3>Объектная модель</h3>
<p><a name='Спец-атрибуты'></a></p>
<h4>Спец атрибуты</h4>
<ul>
<li><code>class.__bases__</code> - вернет кортеж базовых классов объекта</li>
<li><code>object.__dict__</code> - возвращает словарь атрибутов объекта</li>
</ul>
<p><a name='Реализация-доступа-по-индексу'></a></p>
<h4>Реализация доступа по индексу</h4>
<p>Для того, чтобы реализовать у класса доступ по индексу. В нём нужно определить 
2 основных метода <code>__getitem__</code> и <code>__setitem__</code>.
<code>__getitem__</code> - отвечает за получение данных содержащихся по указанному индексу.
<code>__setitem__</code> - отвечает за присваивание объекту по индексу.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Test</span>:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__init__</span>(<span style="color: #007020">self</span>, <span style="color: #666666">*</span>args):
        <span style="color: #007020">self</span><span style="color: #666666">.</span>data <span style="color: #666666">=</span> <span style="color: #007020">list</span>(args)

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__getitem__</span>(<span style="color: #007020">self</span>, item):
        <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">        Вызывается при доступе к атрибуту класса или по индексу</span>
<span style="color: #4070a0; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #007020; font-weight: bold">if</span> <span style="color: #007020">isinstance</span>(item, <span style="color: #007020">str</span>):
            <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">getattr</span>(<span style="color: #007020">self</span>, item)
        <span style="color: #007020; font-weight: bold">else</span>:
            <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>data[item]

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__setitem__</span>(<span style="color: #007020">self</span>, key, value):
        <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">        Вызывается при присваивании по индексу</span>
<span style="color: #4070a0; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #007020">self</span><span style="color: #666666">.</span>data[key] <span style="color: #666666">=</span> value

test <span style="color: #666666">=</span> Test(<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>)
<span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Доступ атрибуту класса&#39;</span>, test<span style="color: #666666">.</span>data)
<span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Доступ по индексу</span><span style="color: #4070a0; font-weight: bold">\n</span><span style="color: #4070a0">&#39;</span>, test[<span style="color: #40a070">1</span>])

test[<span style="color: #40a070">0</span>] <span style="color: #666666">=</span> <span style="color: #40a070">11</span>
<span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Присвоили данные по индексу&#39;</span>, test<span style="color: #666666">.</span>data)
test<span style="color: #666666">.</span>data <span style="color: #666666">=</span> [<span style="color: #4070a0">&#39;новый&#39;</span>, <span style="color: #4070a0">&#39;список&#39;</span>]
<span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Присвоили данные через атрибут класса&#39;</span>, test<span style="color: #666666">.</span>data)
</code></pre></div>
<p><a name='Протокол-итераторов'></a></p>
<h4>Протокол итераторов</h4>
<p>Работая с python Вы каждый день сталкиваетесь с необходимостью пробежаться по
всем строкам файла или перебрать все элементы списка, словаря или какой-то 
другой коллекции. Наверняка решаете Вы эту задачу простым циклом <code>for</code>.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>]:
    <span style="color: #007020">print</span>(i)
</code></pre></div>
<p>Вы можете так делать благодаря тому, что эти объекты реализуют протокол 
итераторов. Это значит что они реализуют интерфейс благодаря которому цикл 
<code>for</code> знает как их перебрать.</p>
<p>Для того, чтобы класс написаный вами тоже можно было использовать в цикле 
<code>for</code>, необходимо переопределить методы: <code>__iter__</code>, <code>__next__</code>.</p>
<p>Метод  <code>__iter__</code> вызывается циклом <code>for</code> в самом начале и возвращает 
итератор, при помощи которого можно последовательно перебрать все элементы
контейнера.</p>
<p>Итератор возвращенный методом <code>__iter__</code> должен реализовывать метод <code>__next__</code>,
который при каждом вызове будет возвращать следующий объект контейнера и так
до тех пор пока элементы не кончатся. Когда элементы кончились он должен 
возбудить исключение <code>StopIteration</code>, которое сведетельствует о том, что все 
элементы контейнера были перебраны.</p>
<p>Примеры:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">MyList</span>:

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__init__</span>(<span style="color: #007020">self</span>, <span style="color: #666666">*</span>args):
        <span style="color: #007020">self</span><span style="color: #666666">.</span>data <span style="color: #666666">=</span> args
        <span style="color: #007020">self</span><span style="color: #666666">.</span>index <span style="color: #666666">=</span> <span style="color: #40a070">0</span>

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__iter__</span>(<span style="color: #007020">self</span>):
        <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">        Вызывается циклом for, в самом начале, чтобы получить объект,</span>
<span style="color: #4070a0; font-style: italic">        который реализует метод __next__, чтобы производить его обход.</span>
<span style="color: #4070a0; font-style: italic">        Так как данный класс реализует метод __next__, данный метод</span>
<span style="color: #4070a0; font-style: italic">        просто возвращает self.</span>
<span style="color: #4070a0; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span>

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__next__</span>(<span style="color: #007020">self</span>):
        <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">        Выдаёт циклу очередной элемент, а когда элементы заканчиваются,</span>
<span style="color: #4070a0; font-style: italic">        возбуждает исключение StopIteration</span>
<span style="color: #4070a0; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #007020; font-weight: bold">try</span>:
            data <span style="color: #666666">=</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>data[<span style="color: #007020">self</span><span style="color: #666666">.</span>index]
            <span style="color: #007020">self</span><span style="color: #666666">.</span>index <span style="color: #666666">+=</span> <span style="color: #40a070">1</span>
        <span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">IndexError</span>:
            <span style="color: #007020">self</span><span style="color: #666666">.</span>index <span style="color: #666666">=</span> <span style="color: #40a070">0</span>
            <span style="color: #007020; font-weight: bold">raise</span> <span style="color: #007020">StopIteration</span>
        <span style="color: #007020; font-weight: bold">return</span> data

my_list <span style="color: #666666">=</span> MyList(<span style="color: #40a070">0</span>, <span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>, <span style="color: #40a070">4</span>)
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> my_list:
    <span style="color: #007020">print</span>(i)
</code></pre></div>
<p>Перебор всех атрибутов класса:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">MyList</span>:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__init__</span>(<span style="color: #007020">self</span>):
        <span style="color: #007020">self</span><span style="color: #666666">.</span>atr1 <span style="color: #666666">=</span> <span style="color: #40a070">0</span>
        <span style="color: #007020">self</span><span style="color: #666666">.</span>atr2 <span style="color: #666666">=</span> <span style="color: #40a070">1</span>
        <span style="color: #007020">self</span><span style="color: #666666">.</span>atr3 <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;привет&#39;</span>
        <span style="color: #007020">self</span><span style="color: #666666">.</span>atr4 <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>]

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__iter__</span>(<span style="color: #007020">self</span>):
        <span style="color: #4070a0; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #4070a0; font-style: italic">        Вызывается циклом for, в самом начале, чтобы получить объект,</span>
<span style="color: #4070a0; font-style: italic">        который реализует метод __next__, чтобы производить его обход.</span>
<span style="color: #4070a0; font-style: italic">        Чтобы выполнять итерации над атрибутами класса используем </span>
<span style="color: #4070a0; font-style: italic">        метод __dict__, который содержит словарь атрибутов класса. </span>
<span style="color: #4070a0; font-style: italic">        Функция iter  добавляет в объект метод __next__, для</span>
<span style="color: #4070a0; font-style: italic">        поддержки итераций.</span>
<span style="color: #4070a0; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">iter</span>(<span style="color: #007020">self</span><span style="color: #666666">.</span><span style="color: #bb60d5">__dict__</span><span style="color: #666666">.</span>values())

my_list <span style="color: #666666">=</span> MyList()

<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> my_list:
    <span style="color: #007020">print</span>(i)
</code></pre></div>
<p><a name='Отличие-__getattr__-от-__getattribute__'></a></p>
<h4>Отличие <code>__getattr__</code> от <code>__getatrribute__</code></h4>
<p><strong><code>__getattr__</code></strong></p>
<p>Вызывается в тех случая, когда у класса пытаются запросить атрибут, который 
не определен ещё. По этому мы можем переопределить его и указать классу, что 
делать при доступе к несуществующему атрибуту.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Foo</span>:
<span style="color: #666666">...</span>     some <span style="color: #666666">=</span> <span style="color: #40a070">1</span>
<span style="color: #666666">...</span>     <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__getattr__</span>(<span style="color: #007020">self</span>, item):
<span style="color: #666666">...</span>         <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Атрибута &quot;</span><span style="color: #70a0d0; font-style: italic">{}</span><span style="color: #4070a0">&quot; не существует&#39;</span><span style="color: #666666">.</span>format(item))
<span style="color: #666666">...</span> 
<span style="color: #666666">&gt;&gt;&gt;</span> foo <span style="color: #666666">=</span> Foo()
<span style="color: #666666">&gt;&gt;&gt;</span> foo<span style="color: #666666">.</span>some
<span style="color: #40a070">1</span>
<span style="color: #666666">&gt;&gt;&gt;</span> foo<span style="color: #666666">.</span>some1
Атрибута <span style="color: #4070a0">&quot;some1&quot;</span> не существует
</code></pre></div>
<p><strong><code>__getattribute__</code></strong></p>
<p>Вызывается при попытке доступа к атрибутам (существующим/не существующим).</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Foo</span>:
<span style="color: #666666">...</span>     some <span style="color: #666666">=</span> <span style="color: #40a070">1</span>
<span style="color: #666666">...</span>     <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__getattribute__</span>(<span style="color: #007020">self</span>, item):
<span style="color: #666666">...</span>         <span style="color: #007020">print</span>(<span style="color: #4070a0">&#39;Обращение к атрибуту &quot;</span><span style="color: #70a0d0; font-style: italic">{}</span><span style="color: #4070a0">&quot;&#39;</span><span style="color: #666666">.</span>format(item))
<span style="color: #666666">...</span> 
<span style="color: #666666">&gt;&gt;&gt;</span> foo <span style="color: #666666">=</span> Foo()
<span style="color: #666666">&gt;&gt;&gt;</span> foo<span style="color: #666666">.</span>some
Обращение к атрибуту <span style="color: #4070a0">&quot;some&quot;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> foo<span style="color: #666666">.</span>some1
Обращение к атрибуту <span style="color: #4070a0">&quot;some1&quot;</span>
</code></pre></div>
<p>Если в классе одновременно определены оба эти метода, то <code>__getattr__</code> больше 
не будет вызываться. Вместо него будет использоваться <code>__getattribute__</code>.</p>
<p><a name='MRO'></a></p>
<h4>MRO</h4>
<ul>
<li><a href="https://bartash.wordpress.com/2017/06/14/mro-in-python/">MRO в Python, или Геометрия бриллианта</a></li>
<li><a href="https://habr.com/post/62203/">Порядок разрешения методов в Python</a></li>
</ul>
<p><a name='Исключения'></a></p>
<h2>Исключения</h2>
<p><a name='Извлечение-traceback'></a></p>
<h3>Извлечение traceback</h3>
<p>Иногда бывает нужно получить в виде строки полный traceback ошибки, это можно
сделать следующим способом:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">traceback</span>

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">foo</span>():
    a <span style="color: #666666">=</span> <span style="color: #40a070">5</span> <span style="color: #666666">/</span> <span style="color: #40a070">0</span>

<span style="color: #007020; font-weight: bold">try</span>:
    foo()
<span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">Exception</span> <span style="color: #007020; font-weight: bold">as</span> err:
    <span style="color: #007020">print</span>(traceback<span style="color: #666666">.</span>format_exc())
</code></pre></div>
<p><a name='Обработчик-для-не-перехваченных-исключений'></a></p>
<h3>Обработчик для не перехваченных исключений</h3>
<p>Пример ниже показывает как можно залогировать не перехваченные исключения.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">sys</span>
<span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">logging</span>

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">unhandled_exception_hook</span>(exc_type, exc_value, exc_traceback):
    logging<span style="color: #666666">.</span>getLogger(<span style="color: #4070a0">&#39;app-name&#39;</span>)<span style="color: #666666">.</span>error(
        <span style="color: #4070a0">&#39;#CRITICAL Возникла непредвиденная ошибка в работе приложения:&#39;</span>,
        exc_info<span style="color: #666666">=</span>(exc_type, exc_value, exc_traceback)
    )

sys<span style="color: #666666">.</span>excepthook <span style="color: #666666">=</span> unhandled_exception_hook
</code></pre></div>
<p><a name='Цепочки-исключений'></a></p>
<h3>Цепочки исключений</h3>
<p>Цепочки исключений это способ показать, что выбрасываемое исключение является
следствием неудачной попытки обработать другое исключение.</p>
<p>Для формирования цепочек исключений используется дополнение <code>from</code>. При его 
использовании требуется указать ещё одно исключение (класс, либо объект). Этот 
объект будет подвязан к возбуждаемому исключению в атрибут <code>__cause__</code> (атрибут 
поддерживает запись). В результате, если возбуждаемое исключение не обработано, 
то на вывод будут отправлены оба исключения:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">try</span>:
    <span style="color: #007020">print</span>(<span style="color: #40a070">1</span> <span style="color: #666666">/</span> <span style="color: #40a070">0</span>)
<span style="color: #007020; font-weight: bold">except</span> <span style="color: #007020">ZeroDivisionError</span> <span style="color: #007020; font-weight: bold">as</span> e:
    <span style="color: #007020; font-weight: bold">raise</span> <span style="color: #007020">RuntimeError</span>(<span style="color: #4070a0">&#39;Новое исключение&#39;</span>) <span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">e</span>
</code></pre></div>
<p>Данный код говорит о том, что исключение <code>RuntimeError('Новое исключение')</code>
возникло в результате неудачной попытки обработать <code>ZeroDivisionError</code>.</p>
<p>Похожий механизм срабатывает автоматически, если исключение возбуждается 
внутри обработчика, либо блока <code>finally</code> — предыдущее исключение подвязывается 
в атрибут <code>__context__</code> нового:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">try</span>:
    <span style="color: #007020">print</span>(<span style="color: #40a070">1</span> <span style="color: #666666">/</span> <span style="color: #40a070">0</span>)        
<span style="color: #007020; font-weight: bold">except</span>:
    <span style="color: #007020; font-weight: bold">raise</span> <span style="color: #007020">RuntimeError</span>(<span style="color: #4070a0">&#39;Неявная цепочка исключений&#39;</span>)
</code></pre></div>
<p><a name='Сборщик-мусора'></a></p>
<h2>Сборщик мусора</h2>
<p><a name='Как-работает-сборщик-мусора-(gc)'></a></p>
<h3>Как работает сборщик мусора (gc)</h3>
<p>Для очистки памяти в CPython используется сразу 2 способа:</p>
<ul>
<li>подсчет ссылок</li>
<li>сборщик мусора (generational garbage collector он же gc)</li>
</ul>
<p>Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один 
большой недостаток. Он не умеет определять циклические ссылки. Именно из-за 
этого, в питоне существует дополнительный сборщик, именуемый поколенческий GC, 
который следит за объектами с потенциальными циклическими ссылками.</p>
<p>В Python, алгоритм подсчета ссылок является фундаментальным и не может 
отключен, тогда как GC опционален и может быть отключен.</p>
<p><strong>Подсчет ссылок</strong></p>
<p>Алгоритм подсчета ссылок это одна из самых простых техник для сборки мусора. 
Объекты удаляются как только на них больше нет ссылок.</p>
<p>В Python, переменные не хранят значения, а выступают в роли ссылок на объекты. 
То есть когда вы присваивайте значение новой переменной, то сначала создается 
объект с этим значением, а уже потом переменная начинает ссылаться на него. 
На один объект может ссылаться множество переменных.</p>
<p>Каждый объект в Python содержит дополнительное поле (счетчик ссылок), в 
котором хранится количество ссылок на него. Как только кто-то ссылается на 
объект, это поле увеличивается на единицу. Если по какой-то причине ссылка 
пропадает, то это поле уменьшается на один.</p>
<p>Примеры, когда количество ссылок увеличивается:</p>
<ul>
<li>оператор присваивания</li>
<li>передача аргументов</li>
<li>вставка нового объекта в лист (увеличивается количество ссылок для объекта)</li>
</ul>
<p>Как только счетчик ссылок для определенного объекта достигает нуля 
интерпретатор запускает процесс уничтожения объекта. Если удаленный объект 
содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким 
образом, удаление одного объекта может повлечь за собой удаление других. </p>
<p>Например, если удаляется список, то счетчик ссылок во всех его элементах 
уменьшается на один. Если все объекты внутри списка больше нигде не 
используются, то они также будут удалены.</p>
<p>Переменные, которые объявлены вне функций, классов и блоков называются 
глобальными. Как правило, жизненный цикл таких переменных равен жизни Python 
процесса. Таким образом, количество ссылок на объекты на которые ссылаются 
глобальные переменные никогда не падает до нуля.</p>
<p>Переменные, которые объявлены внутри блока (функции, класса) имеют локальную 
видимость (т.е. они видны только внутри блока). Как только интерпретатор 
питона выходит из блока он уничтожает все ссылки созданные локальными 
переменными внутри него.</p>
<p>Вы всегда можете проверить количество ссылок используя 
функцию <code>sys.getrefcount.</code></p>
<p>Пример работы счетчика ссылок:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">sys</span>
<span style="color: #666666">&gt;&gt;&gt;</span> foo <span style="color: #666666">=</span> <span style="color: #4070a0">&#39;Какая-то строка&#39;</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">print</span>(sys<span style="color: #666666">.</span>getrefcount(foo)) 
<span style="color: #40a070">2</span>
<span style="color: #666666">&gt;&gt;&gt;</span> bar <span style="color: #666666">=</span> foo
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">print</span>(sys<span style="color: #666666">.</span>getrefcount(foo)) 
<span style="color: #40a070">3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">del</span> bar
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020">print</span>(sys<span style="color: #666666">.</span>getrefcount(foo)) 
<span style="color: #40a070">2</span>
</code></pre></div>
<p>Данный пример наглядно показывает все то, о чем говорилось ранее. Небольшое 
недоумение может вызвать то, что нам вернулись значения 2, 3, 2, а не 1, 2, 1.
Это объясняется тем, что когда переменная передается в функцию,
то счетчик ссылок увеличивается на единицу (это сделано для того, чтобы объект
не был удален в то время, когда он обрабатывается функцией).</p>
<p>Основная причина, из-за которой стандартный интерпретатор (CPython) использует 
счетчик ссылок, является исторической. В настоящее время можно встретить 
множество дебатов по поводу данного подхода. Некоторые люди считают, что 
сборщик мусора может быть намного эффективней без участия алгоритма подсчета 
ссылок. У данного алгоритма есть множество проблем, таких как циклические 
ссылки, блокирование потоков, а также дополнительные накладные расходы на 
память и cpu.</p>
<p>Основным плюсом этого алгоритма является то, что объекты удаляются сразу как 
только они не нужны. </p>
<p><strong>Garbage Collector</strong></p>
<p>Задача GC обрабатывать ситуации, когда у нас есть объекты у которых счетчик 
ссылок не 0, но они более не достижимы из кода. То есть он нужен только для
удаления объектов с циклическими ссылками, которые не были удалены алгоритмом
работающим по умолчанию и опирающимся на подсчете ссылок.</p>
<p>Ниже приведен пример визуализирующий проблему циклических ссылок, которую 
решает GC.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">ctypes</span>
<span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">gc</span>

<span style="color: #60a0b0; font-style: italic"># выключаем GC</span>
gc<span style="color: #666666">.</span>disable()


<span style="color: #60a0b0; font-style: italic"># используется ctypes для доступа к объектам по адресу памяти</span>
<span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">PyObject</span>(ctypes<span style="color: #666666">.</span>Structure):
    _fields_ <span style="color: #666666">=</span> [(<span style="color: #4070a0">&quot;refcnt&quot;</span>, ctypes<span style="color: #666666">.</span>c_long)]


object_1 <span style="color: #666666">=</span> {}
object_2 <span style="color: #666666">=</span> {}
object_1[<span style="color: #4070a0">&#39;obj2&#39;</span>] <span style="color: #666666">=</span> object_2
object_2[<span style="color: #4070a0">&#39;obj1&#39;</span>] <span style="color: #666666">=</span> object_1

obj_address <span style="color: #666666">=</span> <span style="color: #007020">id</span>(object_1)

<span style="color: #60a0b0; font-style: italic"># Удаляем ссылки, таким образом объекты более недоступны в программе, </span>
<span style="color: #60a0b0; font-style: italic"># но счетчик ссылок у них не 0</span>
<span style="color: #007020; font-weight: bold">del</span> object_1, object_2

<span style="color: #60a0b0; font-style: italic"># раскомментируйте для принудительного запуска gc, чтобы убедится, что он </span>
<span style="color: #60a0b0; font-style: italic"># удалит недостижимые объекты</span>
<span style="color: #60a0b0; font-style: italic"># gc.collect()</span>

<span style="color: #60a0b0; font-style: italic"># проверяем счетчик ссылок</span>
<span style="color: #007020">print</span>(PyObject<span style="color: #666666">.</span>from_address(obj_address)<span style="color: #666666">.</span>refcnt)
</code></pre></div>
<p>В примере выше, инструкция del удаляет ссылки на наши объекты (не сами 
объекты). Как только Python выполняет инструкцию del эти объекты становятся 
недоступны из Python кода. Однако, с выключенным модулем gc они по прежнему 
будут оставаться в памяти, т.к. они имели циклические ссылки и их счетчик по 
прежнему равен единице. Вы можете визуально исследовать такие связи используя 
библиотеку objgraph. </p>
<p>Циклические ссылки могут происходить только в “контейнерных” объектах. Т.е. 
в объектах, которые могут хранить другие объекты, например в списках, словарях,
классах и кортежах. GC не следит за простыми и неизменяемыми типами, за 
исключением кортежей. Некоторые кортежи и словари так же исключаются из списка 
слежки при выполнении определенных условий. Со всеми остальными объектами 
гарантированно справляется алгоритм подсчета ссылок.</p>
<p><strong>Поколения</strong></p>
<p>Поиск недостижимых из кода программы объектов может занимать очень много 
времени, по этому все объекты разделяются на 3 поколения (0, 1, 2), чем дольше
живет объект, тем в более старшем поколении он будет находится. Поколения 
представляют из себя обычные списки, с которыми работает gc.</p>
<p>Алгоритм распределения по поколениям:</p>
<ul>
<li>в поколение 0 попадают все новые объекты, кроме тех, которые НЕ могут 
ссылаться на другие объекты (примерами таких объектов могут служить объекты 
типов str, int and etc);</li>
<li>в 1 поколение попадают те объекты, которые не были удалены во время нулевой
чистки;</li>
<li>во 2 поколения попадают объекты пережившие чистку в поколении 1.</li>
</ul>
<p>Момент запуска GC определяется при помощи специальных значений называемых 
threshold. Для каждого поколения имеется свое знанчение threshold. Посмотреть 
эти значения можно вот так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">gc</span>
<span style="color: #666666">&gt;&gt;&gt;</span> gc<span style="color: #666666">.</span>get_threshold()
(<span style="color: #40a070">700</span>, <span style="color: #40a070">10</span>, <span style="color: #40a070">10</span>)
</code></pre></div>
<p>Таким образом GC запускается:
- для поколения 0 - когда выполняется следующие условие:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>(количесто созданных объектов - количество удаленных объектов) &gt; 700
</code></pre></div>
<ul>
<li>для поколения 1 - после того как GC 10 раз отработал для поколения 0</li>
<li>для поколения 2 - после того GC 10 раз раз отработал для поколения 1</li>
</ul>
<p>Значения threshold можно изменять при помощи функции <code>gc.set_threshold</code>.</p>
<p><strong>Ограничения GC</strong></p>
<p>GC не может корректно обрабатывать объекты с переопределенным деструктором 
(<code>__del__</code>), потому что он просто не знает в каком порядке их вызывать, чтобы 
не наткнуться в очередном деструкторе на вызов уже удаленного объекта. По этому
объекты с переопредленным деструктором, а так же другие объекты, которые gc
не знает как удалить, он помещает в <code>gc.garbage</code>. </p>
<p>Для того, чтобы очистить этот список, нужно перебрать все элементы этого списка
и разорвать все циклические ссылки (<code>gc.get_referrers</code>). После этого данный 
список можно очистить и тогда python сам удалит эти объекты основываясь на
посчете ссылок.</p>
<p>P.S. учитывая сложность и множество нюансов работы с <code>__del__</code>, лучше не 
использовать их.</p>
<p>Стоить отметить, что данная проблема была решена в Python 3.4 
(подробнее в <a href="http://legacy.python.org/dev/peps/pep-0442/">PEP 442</a>)</p>
<p><strong>Советы по оптимизации</strong></p>
<p>Циклы зачастую случаются в реальных задачах, их можно встретить в задачах с 
графами, связными списками или в структурах данных, где требуется вести учёт 
отношений между объектами. Если ваша программа имеет высокую нагрузку и 
требовательна к задержкам, то, по возможности, циклы лучше избегать. </p>
<p>В местах, где вы заведомо используйте циклические ссылки, можно использовать 
«слабые» ссылки. Слабые ссылке реализованы в модуле weakref и в отличие от 
обычных ссылок никак не влияют на счётчик ссылок. Если объект со слабой ссылок 
оказывается удалённым, то вместо него возвращается None.</p>
<p>В некоторых случаях полезно отключить автоматическую сборку модулем gc и 
вызывать его вручную. Для этого достаточно вызывать gc.disable() и в 
дальнейшем вызывать gc.collect() вручную.</p>
<p>Материалы используемые для написания заметки:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=6Iw6n43mrVI">Garbage collector &amp; a bit of memory management - Кирилл Лашкевич - Python Meetup 27.09.2013</a></li>
<li><a href="https://habr.com/post/417215/">Всё, что нужно знать о сборщике мусора в Python - Habr</a></li>
<li><a href="https://asvetlov.blogspot.com/2013/05/gc.html">Удаление объектов сборщиком мусора - asvetlov</a></li>
<li><a href="http://python-3.ru/page/podschet-ssylok-i-sborka-musora-v-python">Подсчет ссылок и сборка мусора в Python</a></li>
</ul>
<p><a name='Многозадачность'></a></p>
<h2>Многозадачность</h2>
<p><a name='Сравнение-асинхронности-и-многопоточности-Описание-роли-GIL-во-всем-этом'></a></p>
<h3>Сравнение асинхронности и многопоточности. Описание роли GIL во всем этом.</h3>
<p>Не один раз видел, что не все программисты на Python понимают, в каких случаях 
стоит создавать отдельный процесс, а когда можно обойтись потоком. Да и к 
тому-же, сейчас многие могут думать, что AsyncIO — самый правильный способ 
писать веб-приложения. Я попробую объяснить разницу между этими формами 
многозадачности в Python и когда их лучше применять.</p>
<p>Задачи в компьютере делятся на два вида:</p>
<p><strong>CPU Bound</strong> — операции, задействующие центральный процессор. Как правило, это 
вычисления: работа с матрицами, изображениями, анализ больших массивов данных, 
вычисление последовательности Фибоначчи или майнинг биткоинов.</p>
<p><strong>I/O Bound</strong> — задачи, использующие ввод/вывод: работу с диском или сетью. К 
таковым относятся веб-сервера или часть веб-приложения, которая принимает 
запросы от клиентов.</p>
<p><strong>Процессы и потоки</strong></p>
<p>Процесс — программа, которая запущена в данный момент. С точки зрения ОС, 
процесс — это структура данных, за которой закреплена область памяти и 
некоторые другие ресурсы, например, открытые им файлы.</p>
<p>Потоки, они же треды или нити — единица исполнения внутри процесса. Часто у 
процесса один поток, называемый основным, но по желанию, программа может 
создать любое их количество. При старте потоку не выделяется отдельных 
ресурсов, вместо этого он использует память и ресурсы породившего его процесса.
За счет этого потоки быстро стартуют и останавливаются.</p>
<p>Обеспечением многозадачности занимается планировщик — часть ядра ОС, которая по
очереди загружает потоки исполнения в центральный процессор.</p>
<p>На одном ядре процессора в единицу времени выполняется один поток. Он работает 
до тех пор, пока не израсходует свой квант времени (по умолчанию равен 100 мс) 
или сам не уступит управление следующему потоку, совершив системный вызов. 
В Python каждый процесс и поток — это нативный процесс и поток операционной 
системы, так что, для него эти утверждения так-же верны.</p>
<p>Но в эталонной реализации Python — CPython присутствует печально известный GIL 
(Global Interpreter Lock), по сути, глобальный семафор, который не дает 
одновременно работать больше чем одному потоку в рамках процесса интерпретатора.</p>
<p><strong>Несколько фактов о GIL</strong></p>
<ul>
<li>
<p>GIL защищает структуры данных работающего потока от проблем конкурентного 
доступа. Например, предотвращает состояние гонки при изменении значения счетчика
ссылок объекта.</p>
</li>
<li>
<p>GIL упрощает интеграцию non thread safe библиотек на С. Благодаря GIL у нас 
так много быстрых модулей и биндингов почти ко всему.</p>
</li>
<li>
<p>Библиотекам на C доступен механизм управления GIL. Так например NumPy 
отпускает его на долгих операциях.</p>
</li>
</ul>
<p>Когда поток начинает работу, он выполняет захват GIL. Спустя какое-то время 
планировщик процессов решает, что текущий поток поработал достаточно, и 
передает управление следующему потоку. Поток №2 видит, что GIL захвачен, так 
что он не продолжает работу, а погружает себя в сон, уступая процессор потоку №1.</p>
<p>Но поток не может удерживать GIL бесконечно. До Python 3.3 GIL переключался 
каждые 100 инструкций машинного кода. В поздних версиях GIL может быть удержан 
потоком не дольше 5 мс. GIL так-же освобождается, если поток совершает 
системный вызов, работает с диском или сетью.</p>
<p>По сути, GIL в питоне делает бесполезной идею применять потоки для параллелизма
в вычислительных задачах. Они будут работать последовательно даже на 
многопроцессорной системе. На CPU Bound задачах программа не ускорится, а 
только замедлится, так как теперь потокам придется делить пополам процессорное
время. При этом I/O операции GIL не замедлит, так как перед системным вызовом
поток отпускает GIL.</p>
<p>На этой грустной ноте можно придти к выводу, что для распараллеливания задач, 
которые завязаны на ввод/вывод хватит и тредов. А вот вычислительные задачи 
следует запускать в отдельных процессах.</p>
<p><strong>Сопрограммы и AsyncIO</strong></p>
<p>Теперь представим, что мы пишем HTTP или WebSocket сервер, который каждое 
подключение обрабатывает в отдельном потоке.</p>
<p>Здесь вполне можно создать 100, может даже 500 потоков, чтобы обработать 
нужное количество одновременных соединений. Для коротких запросов это даже 
будет работать и позволит выдержать нагрузку в 5000 RPS на самом дешевом 
инстансе в DO за пять баксов — вполне неплохо. Если у вас меньше, возможно 
здесь и не нужны никакие AsyncIO/Tornado/Twisted.</p>
<p>Но что, если их количество стремится к бесконечности? Скажем, это большой чат 
с кучей каналов, где количество одновременных участников не ограничено. В 
такой ситуации создать столько потоков, чтобы хватило каждому пользователю я 
бы уже не рискнул. И вот почему:</p>
<p>Как говорилось выше, пока GIL захвачен одним потоком, другие работать не будут.
Планировщик операционной системы, при этом, о GIL ничего не знает и все равно 
будет отдавать процессор заблокированный потокам. Такой поток, конечно, увидит 
что GIL захвачен и сразу же уснет, но на переключение контекста процессора 
будет тратиться драгоценное время.</p>
<p>Переключение контекста — вообще дорогая для процессора операция, которая 
требует сброса регистров, кэша и таблицы отображения страниц памяти. Чем больше
потоков запущено, тем больше процессор совершает холостых переключений на 
потоки, заблокированные GIL, прежде чем дойдет до того самого, который этот 
GIL удерживает. Не очень-то эффективно.</p>
<p>Есть старые добрые сопрограммы — то, что сейчас предлагает AsyncIO и Tornado. 
Их еще называют корутинами или просто потоками на уровне пользователя. Модная 
нынче штука, но, далеко не новая, а использовалась еще во времена, когда в ходу
были ОС без поддержки многозадачности.</p>
<p>В отличие от потоков, сопрограммы выполняют только полезную работу, а 
переключение между ними происходит только в тот момент, когда сопрограмма 
ожидает завершения какой-то внешней операции.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">asyncio</span>
<span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">aiohttp</span>

<span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">simulate_io</span>():
    <span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">with</span> aiohttp<span style="color: #666666">.</span>ClientSession() <span style="color: #007020; font-weight: bold">as</span> session:
        <span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">with</span> session<span style="color: #666666">.</span>get(<span style="color: #4070a0">&#39;http://python.org&#39;</span>) <span style="color: #007020; font-weight: bold">as</span> resp:
            <span style="color: #007020; font-weight: bold">await</span> resp<span style="color: #666666">.</span>text()

<span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">coro</span>(name):
    <span style="color: #007020; font-weight: bold">await</span> simulate_io()
    <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;</span><span style="color: #70a0d0; font-style: italic">{</span>name<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">-1&#39;</span>)
    <span style="color: #007020; font-weight: bold">await</span> simulate_io()
    <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;</span><span style="color: #70a0d0; font-style: italic">{</span>name<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">-2&#39;</span>)

<span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">main</span>():
    <span style="color: #007020; font-weight: bold">await</span> asyncio<span style="color: #666666">.</span>gather(coro(<span style="color: #4070a0">&#39;A&#39;</span>), coro(<span style="color: #4070a0">&#39;B&#39;</span>))

loop <span style="color: #666666">=</span> asyncio<span style="color: #666666">.</span>get_event_loop()
loop<span style="color: #666666">.</span>run_until_complete(main())
</code></pre></div>
<p>Результаты получим примерно в таком порядке: A-1 B-1 A-2 B-2. Из примера видно,
что сопрограммы работали по очереди, при этом все происходит в одном потоке. 
Когда сопрограмма A вызывает <code>simulate_io()</code>, управление передаётся сопрограмме 
B. Она делает тот-же вызов и управление возвращается сопрограмме A, которая 
печатает результат, так как I/O для неё уже завершился и переходит ко 
следующему вызову <code>simulate_io()</code>.</p>
<p>Как и в случае с тредами, асинхронщина бесполезна для вычислений. Тут ситуация 
даже хуже, так как зависший на вычислениях поток рано или поздно GIL отпустит, 
а вот блокирующий код в сопрограмме заблокирует весь поток, до тех пор, пока не
исполнится весь. В отличии от нативных тредов, у сопрограмм отсутствует 
прерывание по таймеру. Передача управления следующей сопрограмме происходит 
вручную, при явном вызове конструкции await (или yield, если используются 
generator-based корутины). Поэтому важно следить, чтобы в асинхронных 
программах не было блокирующего кода и использовались только асинхронные 
вызовы, а все вычисления происходили в отдельных процессах.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">fib</span>(n):
    <span style="color: #007020; font-weight: bold">if</span> n <span style="color: #666666">&lt;=</span> <span style="color: #40a070">2</span>:
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #40a070">1</span>
    <span style="color: #007020; font-weight: bold">return</span> fib(n <span style="color: #666666">-</span> <span style="color: #40a070">1</span>) <span style="color: #666666">+</span> fib(n <span style="color: #666666">-</span> <span style="color: #40a070">2</span>)

<span style="color: #007020; font-weight: bold">async</span> <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">coro</span>(name):
    <span style="color: #007020; font-weight: bold">await</span> simulate_io()
    <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;</span><span style="color: #70a0d0; font-style: italic">{</span>name<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">-1&#39;</span>)
    fib(<span style="color: #40a070">35</span>)  <span style="color: #60a0b0; font-style: italic"># здесь весь поток блокируется</span>
    <span style="color: #007020; font-weight: bold">await</span> simulate_io()
    <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;</span><span style="color: #70a0d0; font-style: italic">{</span>name<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">-2&#39;</span>)
</code></pre></div>
<p><strong>Итого</strong></p>
<p>Потоки будут проще, если у вас типичное веб-приложение, которое не зависит от 
внешних сервисов, и относительно конечное количество клиентов, для которых 
время ответа будет предсказуемо-коротким.</p>
<p>AsyncIO подойдет, если приложение большую часть времени тратит на чтение/запись
данных, а не их обработку. Например, у вас много медленных запросов — 
вебсокеты, long polling или есть медленные внешние синхронные бекенды, запросы
к которым неизвестно когда завершатся.</p>
<p>Ссылки по теме:</p>
<ul>
<li><a href="https://maxpoletaev.ru/blog/async-python/">Асинхронный Python и различные формы многозадачности</a> - отсюда 
 взят текст статьи</li>
<li><a href="https://www.youtube.com/watch?v=AWX4JnAnjBE">GIL в Python: зачем он нужен и как с этим жить - Григорий Петров</a> - в 
 данном видео текст заметки раскрыт гораздо лучше</li>
</ul>
<p><a name='В-чем-отличие-конкурентности-от-многопоточности'></a></p>
<h3>В чем отличие конкурентности от многопоточности</h3>
<p>Отличие конкуретного подхода от многопоточного, заключается в том, что 
потоками управляет ОС и она производит их переключение по своему алгоритму,
на который нельзя повлиять, а сопрограммами управляет event loop, который 
производит переключение в "правильный" момент времени, то есть когда для 
коррутины появилась работа (на пример пришли данные по сети).</p>
<p>Ссылки на использованные материалы:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread">Difference between a “coroutine” and a “thread”? - stackoverflow.com</a></li>
</ul>
<p><a name='Асинхронность-в-python'></a></p>
<h3>Асинхронность в python</h3>
<p><a href="https://www.youtube.com/watch?v=OEFsdk1tqAU">Алексей Кузьмин (Domclick) - Асинхронное программирование в Python</a>, 
<a href="https://cloud.mail.ru/public/59GN/36QyzVCXE">копия</a>, <a href="https://cloud.mail.ru/public/3TxW/2e2487e6i">презентация</a>,
<a href="https://github.com/fantomius/AsyncPython/tree/master">скрипты с доклада</a> - хороший 
доклад рассказывающий о том, как реализована асинхронность в python. Объяснение 
ведется на примерах, которые показывают как написать асинхронный код не 
используя библиотеки вроде aiohttp.</p>
<p><a href="https://www.youtube.com/watch?v=pZkerqks43Y">Алексей Кузьмин (ДомКлик) - Асинхронность изнутри</a>,
<a href="https://cloud.mail.ru/public/3jm2/3NGxXo5Q9">копия</a> - продолжение 
предыдущего доклада, в котором подробно на простых примерах рассказывается, что
из себя представляет асинхронный код. Хорошо рассказаны все основы.</p>
<p><a href="https://www.youtube.com/watch?v=x6JZmBK2I8Y">Алексей Кладов - async / await (2018) (Computer Science Center)</a>,
<a href="https://cloud.mail.ru/public/2irA/2SUoGXmYD">копия</a></p>
<p><a href="https://www.youtube.com/watch?v=z7WIm0iZcOU">Асинхронный Python-код медленнее обычного кода! Ааа!!1один. Aiohttp VS синхронные фреймворки - Диджитализируй!</a>,
<a href="https://cloud.mail.ru/public/mYPT/XU8pWyPE4">копия</a> - автор разбирает один из бенчмарков в котором сравнивается 
производительность асинхронного и синхронного кода, объясняет почему получились те или иные значения и подробно 
рассказывает для чего хорош асинхронный код, а для чего синхронный.</p>
<p><a name='Аннотации-типов'></a></p>
<h2>Аннотации типов</h2>
<p><a name='Введение-в-type-hints'></a></p>
<h3>Введение</h3>
<p><strong>Что такое type hints и зачем они нужны?</strong></p>
<p>Подсказки типов/аннотации типов помогают сделать код более явным, улучшить его
читаемость и дают возможность выполнять автоматизированную проверку корректности
написанного (статический анализ).</p>
<p>Вот простой пример как выглядят аннотации типов.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">add</span>(a: <span style="color: #007020">int</span>, b: <span style="color: #007020">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">int</span>:
    <span style="color: #007020; font-weight: bold">return</span> a <span style="color: #666666">+</span> b
</code></pre></div>
<p>Найти больше полезных примеров вы можете найти на одной из 
<a href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">страниц</a> документации mypy.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://dev.to/decorator_factory/type-hints-in-python-tutorial-3pel">Get started with type hints in Python</a> - не 
  плохо описано введение в аннотации типов.</li>
</ul>
<p><a name='Generic-type-variables-TypeVar'></a></p>
<h3>Generic type variables (TypeVar)</h3>
<p><strong>Проблема</strong></p>
<p>Иногда бывает нужно добавить аннотации типов в функцию, которая может работать с 
любыми типами. На пример она принимает какие-то данные и возвращает их без 
изменения. Как в таком случае поступить?</p>
<p>Можно попытаться решить это различными способами, например:</p>
<ul>
<li>проаннотировать параметр функции как <code>Any</code> и поставить возвращаемый тип <code>Any</code>. Это
  будет работать, но мы потеряем тип изначальной переменной и инструменты вроде 
  <code>mypy</code> не смогут помочь найти нам ошибки в нашем коде.</li>
</ul>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> Any

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">identity</span>(arg: Any) <span style="color: #666666">-&gt;</span> Any:
    <span style="color: #007020; font-weight: bold">return</span> arg
</code></pre></div>
<ul>
<li>создать специализированные версии функций под различные типы параметров.
  Это будет работать, но мы будем писать много бесполезного, кода который 
  нужно будет поддерживать + наверняка упустим какой-то из возможных кейсов 
  использования нашего кода.</li>
</ul>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">identity_int</span>(arg: <span style="color: #007020">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">int</span>:
    <span style="color: #007020; font-weight: bold">return</span> arg

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">identity_str</span>(arg: <span style="color: #007020">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">str</span>:
    <span style="color: #007020; font-weight: bold">return</span> arg

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">identity_list_str</span>(arg: <span style="color: #007020">list</span>[<span style="color: #007020">str</span>]) <span style="color: #666666">-&gt;</span> <span style="color: #007020">list</span>[<span style="color: #007020">str</span>]:
    <span style="color: #007020; font-weight: bold">return</span> arg

<span style="color: #666666">...</span>
</code></pre></div>
<p><strong>Решение</strong></p>
<p>Нужно использовать дженерик переменную. Дженерик переменные позволяют связать
несколько типов вместе. Вот как вы можете использовать их для аннотирования 
функции <code>identity</code>:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> TypeVar

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;T&quot;</span>)

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">identity</span>(arg: T) <span style="color: #666666">-&gt;</span> T:
    <span style="color: #007020; font-weight: bold">return</span> arg
</code></pre></div>
<p>Здесь тип возвращаемого значения «связан» с типом параметра, то есть что бы вы ни вложили
в функцию, на выходе будет то же самое.</p>
<p>Важно заметить, если вы попытаетесь вернуть из функции, что-то что не связанное с 
аргументом (даже если эти данные будут того же типа), то это будет ошибкой и mypy 
будет ругаться на это.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> List, TypeVar

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;T&quot;</span>)

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">first</span>(container: List[T]) <span style="color: #666666">-&gt;</span> T:
    <span style="color: #007020">print</span>(container)
    <span style="color: #007020; font-weight: bold">return</span> <span style="color: #4070a0">&quot;a&quot;</span> <span style="color: #60a0b0; font-style: italic"># mypy raises: Incompatible return value type (got &quot;str&quot;, expected &quot;T&quot;)</span>

<span style="color: #007020; font-weight: bold">if</span> <span style="color: #bb60d5">__name__</span> <span style="color: #666666">==</span> <span style="color: #4070a0">&quot;__main__&quot;</span>:
    list_one: List[<span style="color: #007020">str</span>] <span style="color: #666666">=</span> [<span style="color: #4070a0">&quot;a&quot;</span>, <span style="color: #4070a0">&quot;b&quot;</span>, <span style="color: #4070a0">&quot;c&quot;</span>]
    <span style="color: #007020">print</span>(first(list_one))
</code></pre></div>
<p><strong>Ограничение возможных типов</strong></p>
<p>TypeVar позволяет вам ограничить возможные типы данных, которые могут быть переданы 
в нашу функцию. Это полезно, если мы хотим "подсветить", что наша функция умеет 
работать только с ограниченным количеством данных.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> TypeVar

AnyString <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;AnyString&quot;</span>, <span style="color: #007020">str</span>, <span style="color: #007020">bytes</span>)

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">triple</span>(string: AnyString) <span style="color: #666666">-&gt;</span> AnyString:
    <span style="color: #007020; font-weight: bold">return</span> string <span style="color: #666666">*</span> <span style="color: #40a070">3</span>

unicode_scream <span style="color: #666666">=</span> triple(<span style="color: #4070a0">&quot;A&quot;</span>) <span style="color: #666666">+</span> <span style="color: #4070a0">&quot;!&quot;</span>
bytes_scream <span style="color: #666666">=</span> triple(<span style="color: #4070a0">b&quot;A&quot;</span>) <span style="color: #666666">+</span> <span style="color: #4070a0">b&quot;!&quot;</span>
</code></pre></div>
<p>Другой способ ограничения возможных типов заключается в определении "верхней границы":</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;T&quot;</span>, bound<span style="color: #666666">=</span><span style="color: #007020">int</span>)
</code></pre></div>
<p>Это значит, что данная дженерик переменная сможет быть только int или подклассом int.</p>
<p>В случае, когда вам нужно описать, что параметр функции может иметь несколько типов. 
Более правильно будет использовать дженерик переменную с описанием <code>constrainst</code>, 
а не <code>Union[str, bytes]</code>. Так как при использовании <code>Union</code> инструмент анализирующих
type hints явно не поймет, связь между переданным в функцию параметром и возвращаемым 
результатом и нам придется писать много много условий с <code>isinstance()</code> или <code>type()</code>, 
чтобы проверить тип переменной и быть уверенным в корректности написанного кода.</p>
<p><strong>Использование дженерик переменной в качестве параметра</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> TypeVar

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;T&quot;</span>)

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">first</span>(container: <span style="color: #007020">list</span>[T]) <span style="color: #666666">-&gt;</span> T:
    <span style="color: #007020; font-weight: bold">return</span> container[<span style="color: #40a070">0</span>]

<span style="color: #007020; font-weight: bold">if</span> <span style="color: #bb60d5">__name__</span> <span style="color: #666666">==</span> <span style="color: #4070a0">&quot;__main__&quot;</span>:
    list_one: List[<span style="color: #007020">str</span>] <span style="color: #666666">=</span> [<span style="color: #4070a0">&quot;a&quot;</span>, <span style="color: #4070a0">&quot;b&quot;</span>, <span style="color: #4070a0">&quot;c&quot;</span>]
    <span style="color: #007020">print</span>(first(list_one))
</code></pre></div>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://dev.to/decorator_factory/typevars-explained-hmo"><code>TypeVar</code>s explained</a> - первоисточник</li>
<li><a href="https://medium.com/@steveYeah/using-generics-in-python-99010e5056eb">Using Generics in Python</a></li>
<li><a href="https://mypy.readthedocs.io/en/stable/generics.html#generic-functions">Generic functions - mypy</a></li>
<li><a href="https://stackoverflow.com/questions/2900881/generic-type-parameter-naming-convention-for-java-with-multiple-chars/2900933#2900933">Type Parameter Naming Conventions - stackoverflow</a></li>
</ul>
<p><a name='Определение-generic-классов'></a></p>
<h3>Определение generic классов</h3>
<p>Дженерик типы можно использовать не только с функциями и методами. Их можно 
использовать также и при определении классов. В этом случае дженерик типы будут
указывать с каким типом/типами будет работать тот или иной экземпляр класса.</p>
<p>Перед тем как перейти к описанию собственно класса важно заметить, что большинство
типов контейнеров в python универсальные и можно определить какого типа будет 
содержимое.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>list_one: <span style="color: #007020">list</span>[<span style="color: #007020">str</span>] <span style="color: #666666">=</span> [<span style="color: #4070a0">&quot;a&quot;</span>, <span style="color: #4070a0">&quot;b&quot;</span>, <span style="color: #4070a0">&quot;c&quot;</span>]
<span style="color: #007020">print</span>(list_one)

list_two: <span style="color: #007020">list</span>[<span style="color: #007020">int</span>] <span style="color: #666666">=</span> [<span style="color: #40a070">1</span>, <span style="color: #40a070">2</span>, <span style="color: #40a070">3</span>]
<span style="color: #007020">print</span>(list_two)

dict_one: <span style="color: #007020">dict</span>[<span style="color: #007020">str</span>, <span style="color: #007020">int</span>] <span style="color: #666666">=</span> {<span style="color: #4070a0">&quot;one&quot;</span>: <span style="color: #40a070">1</span>, <span style="color: #4070a0">&quot;two&quot;</span>: <span style="color: #40a070">2</span>}
<span style="color: #007020">print</span>(dict_one)
</code></pre></div>
<p><strong>Создание своего дженерик типа</strong> </p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> Generic, TypeVar

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&quot;T&quot;</span>)

<span style="color: #007020; font-weight: bold">class</span> <span style="color: #0e84b5; font-weight: bold">Registry</span>(Generic[T]):
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">__init__</span>(<span style="color: #007020">self</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020; font-weight: bold">None</span>:
        <span style="color: #007020">self</span><span style="color: #666666">.</span>_store: <span style="color: #007020">dict</span>[<span style="color: #007020">str</span>, T] <span style="color: #666666">=</span> {}

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">set_item</span>(<span style="color: #007020">self</span>, k: <span style="color: #007020">str</span>, v: T) <span style="color: #666666">-&gt;</span> <span style="color: #007020; font-weight: bold">None</span>:
        <span style="color: #007020">self</span><span style="color: #666666">.</span>_store[k] <span style="color: #666666">=</span> v

    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">get_item</span>(<span style="color: #007020">self</span>, k: <span style="color: #007020">str</span>) <span style="color: #666666">-&gt;</span> T:
        <span style="color: #007020; font-weight: bold">return</span> <span style="color: #007020">self</span><span style="color: #666666">.</span>_store[k]

<span style="color: #007020; font-weight: bold">if</span> <span style="color: #bb60d5">__name__</span> <span style="color: #666666">==</span> <span style="color: #4070a0">&quot;__main__&quot;</span>:
    family_name_reg <span style="color: #666666">=</span> Registry[<span style="color: #007020">str</span>]()
    family_age_reg <span style="color: #666666">=</span> Registry[<span style="color: #007020">int</span>]()

    family_name_reg<span style="color: #666666">.</span>set_item(<span style="color: #4070a0">&quot;husband&quot;</span>, <span style="color: #4070a0">&quot;steve&quot;</span>)
    family_name_reg<span style="color: #666666">.</span>set_item(<span style="color: #4070a0">&quot;dad&quot;</span>, <span style="color: #4070a0">&quot;john&quot;</span>)

    family_age_reg<span style="color: #666666">.</span>set_item(<span style="color: #4070a0">&quot;steve&quot;</span>, <span style="color: #40a070">30</span>)
</code></pre></div>
<p>В этом примере мы создали класс <code>Registry</code>. Тип данных, который хранит Registry общий.
Этот тип указывается в момент создания экземпляра класса. После создания каждый из 
экземпляров будет принимать только аргументы этого типа.</p>
<p>Реализуется это при помощи наследования от класса <code>Generic</code> и определения дженерик
типов, которые мы хотим дальше использовать. В нашем случае мы определяем тип <code>T</code>,
который в дальнейшем используется в методах класса <code>Registry</code>.</p>
<p>Когда мы создаем экземпляр <code>family_name_reg</code>, мы заявляем, что он будет содержать только 
значения типа <code>str</code> (с помощью <code>Registry[str]</code>)), а <code>family_age_reg</code> экземпляр будет 
содержать только значения типа <code>int</code> (с помощью <code>Registry[int]</code>).</p>
<p>Используя наш пример выше, если мы попытаемся установить строковое значение в реестре 
возрастов, мы увидим, что mypy вызовет это как ошибку.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>family_age_reg<span style="color: #666666">.</span>set_item(<span style="color: #4070a0">&quot;steve&quot;</span>, <span style="color: #4070a0">&quot;yeah&quot;</span>)
<span style="color: #60a0b0; font-style: italic"># mypy raises: Argument 2 to &quot;set_item&quot; of &quot;Registry&quot; has incompatible type &quot;str&quot;; expected &quot;int&quot;</span>
</code></pre></div>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://medium.com/@steveYeah/using-generics-in-python-99010e5056eb">Using Generics in Python</a></li>
<li><a href="https://mypy.readthedocs.io/en/stable/generics.html#defining-generic-classes">Defining generic classes - mypy</a></li>
</ul>
<p><a name='Аннотирование-декораторов-ParamSpec-Concatenate'></a></p>
<h3>Аннотирование декораторов (ParamSpec, Concatenate)</h3>
<blockquote>
<p>Если вы используете python версии ниже 3.10, вы можете импортировать <code>ParamSpec</code>, 
<code>Concatenate</code> из модуля <code>typing_extensions</code>.</p>
</blockquote>
<p>При описании декораторов есть распространенный шаблон, когда декоратор без изменений
передает в декорируемую функцию все полученные параметры. До <a href="https://peps.python.org/pep-0612/">PEP-612</a>
описать аннотации типов для данного декоратора было нельзя. По этому этот PEP добавляет
ParamSpec переменные, которые решают эту проблему.</p>
<p>Этот тип позволяет описать связь между аргументами передаваемыми в декоратор и аргументами
с которыми вызывается декорируемая функция. Пример как это можно сделать описан ниже:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">time</span>
<span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> ParamSpec, TypeVar, Callable

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&#39;T&#39;</span>)
P <span style="color: #666666">=</span> ParamSpec(<span style="color: #4070a0">&#39;P&#39;</span>)


<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">timeit</span>(func: Callable[P, T]) <span style="color: #666666">-&gt;</span> Callable[P, T]:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>(<span style="color: #666666">*</span>args: P<span style="color: #666666">.</span>args, <span style="color: #666666">**</span>kwargs: P<span style="color: #666666">.</span>kwargs) <span style="color: #666666">-&gt;</span> T:
        start_time <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
        value <span style="color: #666666">=</span> func(<span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs)
        execution_time <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start_time
        <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;The &quot;</span><span style="color: #70a0d0; font-style: italic">{</span>func<span style="color: #666666">.</span><span style="color: #bb60d5">__name__</span><span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">&quot; function took </span><span style="color: #70a0d0; font-style: italic">{</span>execution_time<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0"> seconds&#39;</span>)
        <span style="color: #007020; font-weight: bold">return</span> value

    <span style="color: #007020; font-weight: bold">return</span> wrapper


<span style="color: #555555; font-weight: bold">@timeit</span>
<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">add_one</span>(x: <span style="color: #007020">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">int</span>:
    <span style="color: #007020; font-weight: bold">return</span> x <span style="color: #666666">+</span> <span style="color: #40a070">1</span>


result <span style="color: #666666">=</span> add_one(<span style="color: #40a070">1</span>)
</code></pre></div>
<p>Пример декоратора, который добавляет дополнительные данные к тем, что возвращает декорируемая функция:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">time</span>
<span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> ParamSpec, TypeVar, Callable

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&#39;T&#39;</span>)
P <span style="color: #666666">=</span> ParamSpec(<span style="color: #4070a0">&#39;P&#39;</span>)


<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">timeit</span>() <span style="color: #666666">-&gt;</span> Callable[[Callable[P, T]], Callable[P, <span style="color: #007020">tuple</span>[T, <span style="color: #007020">float</span>]]]:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">decorator</span>(func: Callable[P, T]) <span style="color: #666666">-&gt;</span> Callable[P, <span style="color: #007020">tuple</span>[T, <span style="color: #007020">float</span>]]:
        <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>(<span style="color: #666666">*</span>args: P<span style="color: #666666">.</span>args, <span style="color: #666666">**</span>kwargs: P<span style="color: #666666">.</span>kwargs) <span style="color: #666666">-&gt;</span> <span style="color: #007020">tuple</span>[T, <span style="color: #007020">float</span>]:
            start_time <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter()
            value <span style="color: #666666">=</span> func(<span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs)
            exec_time <span style="color: #666666">=</span> time<span style="color: #666666">.</span>perf_counter() <span style="color: #666666">-</span> start_time
            <span style="color: #007020">print</span>(<span style="color: #4070a0">f&#39;The &quot;</span><span style="color: #70a0d0; font-style: italic">{</span>func<span style="color: #666666">.</span><span style="color: #bb60d5">__name__</span><span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">&quot; function took </span><span style="color: #70a0d0; font-style: italic">{</span>exec_time<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0"> seconds&#39;</span>)
            <span style="color: #007020; font-weight: bold">return</span> value, exec_time

        <span style="color: #007020; font-weight: bold">return</span> wrapper

    <span style="color: #007020; font-weight: bold">return</span> decorator


<span style="color: #555555; font-weight: bold">@timeit</span>()
<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">add_one</span>(x: <span style="color: #007020">int</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">int</span>:
    <span style="color: #007020; font-weight: bold">return</span> x <span style="color: #666666">+</span> <span style="color: #40a070">1</span>


result, execution_time <span style="color: #666666">=</span> add_one(<span style="color: #40a070">1</span>)
</code></pre></div>
<p>Другой распространенный кейс использования декораторов, когда декоратор добавляет или
удаляет какой-то аргумент. С PEP-612 это делается вот так:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">typing</span> <span style="color: #007020; font-weight: bold">import</span> ParamSpec, TypeVar, Callable, Concatenate

T <span style="color: #666666">=</span> TypeVar(<span style="color: #4070a0">&#39;T&#39;</span>)
P <span style="color: #666666">=</span> ParamSpec(<span style="color: #4070a0">&#39;P&#39;</span>)


<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">get_request_id</span>() <span style="color: #666666">-&gt;</span> <span style="color: #007020">str</span>:
    <span style="color: #007020; font-weight: bold">return</span> <span style="color: #4070a0">&#39;1&#39;</span>  <span style="color: #60a0b0; font-style: italic"># Эмулирует получение откуда-то идентификатора запроса</span>


<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">with_request_id</span>(func: Callable[Concatenate[<span style="color: #007020">str</span>, P], T]) <span style="color: #666666">-&gt;</span> Callable[P, T]:
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>(<span style="color: #666666">*</span>args: P<span style="color: #666666">.</span>args, <span style="color: #666666">**</span>kwargs: P<span style="color: #666666">.</span>kwargs) <span style="color: #666666">-&gt;</span> T:
        <span style="color: #007020; font-weight: bold">return</span> func(get_request_id(), <span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs)

    <span style="color: #007020; font-weight: bold">return</span> wrapper


<span style="color: #555555; font-weight: bold">@with_request_id</span>
<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">handler</span>(request_id: <span style="color: #007020">str</span>) <span style="color: #666666">-&gt;</span> <span style="color: #007020">str</span>:
    <span style="color: #007020; font-weight: bold">return</span> <span style="color: #4070a0">f&#39;we are processing your request #</span><span style="color: #70a0d0; font-style: italic">{</span>request_id<span style="color: #70a0d0; font-style: italic">}</span><span style="color: #4070a0">&#39;</span>


result <span style="color: #666666">=</span> handler()
</code></pre></div>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://peps.python.org/pep-0612/">PEP-612</a></li>
<li><a href="https://mypy.readthedocs.io/en/stable/generics.html?highlight=ParamSpec#declaring-decorators">Declaring decorators - mypy</a></li>
<li><a href="https://rednafi.github.io/reflections/static-typing-python-decorators.html">Static typing Python decorators - Redowan's Reflections</a></li>
<li><a href="https://stackoverflow.com/questions/73129698/can-paramspec-be-used-to-type-individual-arguments">Can ParamSpec be used to type individual arguments? - stackoverflow</a></li>
</ul>
<p><a name='Оптимизация-и-профилирование'></a></p>
<h2>Оптимизация и профилирование</h2>
<p><a name='Способы-измерения-производительности'></a></p>
<h3>Способы измерения производительности</h3>
<p><a name='Измерение-производительности-отдельных-функций'></a></p>
<h4>Измерение производительности отдельных функций</h4>
<p>Измерить производительность отдельных функций (их время выполнения) можно при 
помощи функции timeit из модуля timeit.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">timeit</span>

<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">test1</span>():
    res <span style="color: #666666">=</span> [[<span style="color: #40a070">3</span> <span style="color: #007020; font-weight: bold">for</span> x <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">50</span>)] <span style="color: #007020; font-weight: bold">for</span> x <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">50</span>)]

<span style="color: #007020">print</span>(timeit<span style="color: #666666">.</span>timeit(<span style="color: #4070a0">&quot;test1()&quot;</span>, setup<span style="color: #666666">=</span><span style="color: #4070a0">&quot;from __main__ import test1&quot;</span>, number<span style="color: #666666">=</span><span style="color: #40a070">100000</span>))
</code></pre></div>
<p>Первым аргументом функция timeit принимает код, продолжительность работы 
которого нужно измерить. Второй аргумент — это инструкция, которая выполняется 
1 раз, для настройки окружения. Третий агрумент, задаёт число повторных 
запусков тестируемого кода.</p>
<p><a name='Замер-времени-работы-с-помощью-unix-программы-time'></a></p>
<h4>Замер времени работы с помощью unix программы time</h4>
<p>Замерять время выполнения написанной программы можно с помощью стандарной 
Unix программы time (не нужно путать с одноименной программой bash). </p>
<p>Пример: </p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020">time</span> python3 get_email.py
</code></pre></div>
<p>Вывод программы: </p>
<ul>
<li>real 0m2.784s - реальное время выполнения между вызовом и завершением</li>
<li>user 0m0.054s - время CPU, которое занял пользователь (сумма значений 
tms_utime и tms_cutime в структуре struct tms, которая возвращается 
вызовом times)</li>
<li>sys  0m0.010s - время CPU занятое системой (сумма значений tms_stime и 
tms_cstime в структуре struct tms, которая возвращается вызовом times)</li>
</ul>
<p><a name='Примеры-написания-оптимального-кода'></a></p>
<h3>Примеры написания оптимального кода</h3>
<p><a name='Создание-списков-заполненных-определённым-числом'></a></p>
<h4>Создание списков заполненных определённым числом</h4>
<p>Есть задача: «Создать список 50*50 целых чисел и заполненный тройками.».</p>
<p>Её можно решить несколькими способами:</p>
<ul>
<li>Использовать генераторы списков для создания и заполнения списка тройками
    <div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>[[<span style="color: #40a070">3</span> <span style="color: #007020; font-weight: bold">for</span> x <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">50</span>)] <span style="color: #007020; font-weight: bold">for</span> x <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">50</span>)]
</code></pre></div>
    такой способ будет работать, но как показали замеры, работает он 
    достаточно медленно 9.265034271054901.</li>
<li>Использование операции умножения для получения списка
    <div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>[[<span style="color: #40a070">3</span>] <span style="color: #666666">*</span> <span style="color: #40a070">50</span> <span style="color: #007020; font-weight: bold">for</span> _ <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">50</span>)]
</code></pre></div>
    как показали тесты, данный способ работает значительно быстрее 1.407502235029824.</li>
</ul>
<p><a name='Добавление-данных-в-список'></a></p>
<h4>Добавление данных в список</h4>
<p>Добавление большого колличесва данных в список, это распространненая задача и 
решать ее можно по разному. Вот некоторые из вариантов, которые могут 
использоваться:</p>
<ul>
<li>в цикле добавлять данные при помощи метода append</li>
<li>использовать генератор списков</li>
</ul>
<p>Из перечисленных выше вариантов быстрее всего будет отрабатывать генератор
списков и если есть возможность, то лучше использовать его.</p>
<p>Если ситуация не позволяет (на пример перед добавлением должна выполнится 
дополнительная логика), то необходимо использовать следующую оптимизацию:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>res <span style="color: #666666">=</span> []
append <span style="color: #666666">=</span> res<span style="color: #666666">.</span>append
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">10</span>):
    append(<span style="color: #007020">input</span>(<span style="color: #4070a0">&#39;Введите данные: &#39;</span>))
</code></pre></div>
<p>В данном примере мы сохраняем в локальную переменную ссылку на метод <code>append</code>
и потом сразу используем эту ссылку сразу, а не вызываем каждый раз данный метод
у объекта res. Данный подход позволяет нам сэкономить драгоценное время, так 
как python не будет каждый раз искать у объекта метод <code>append</code>.</p>
<p>При написании кода лучше всегда помнить про подобного рода трюк, потому что в 
python lookup`ы в python очень "дорогие".</p>
<p><a name='Советы-по-написанию-оптимального-кода'></a></p>
<h3>Советы по написанию оптимального кода</h3>
<p><a name='Мелкие-классы'></a></p>
<h4>Мелкие классы</h4>
<p>Создание функций более дешёвая операция по сравнению с созданием экземпляра 
класса. По этому если в коде очень часто приходится создать экземпляр 
какого-то класса, нужно подумать как можно переписать этот код. Можно 
постараться избавиться от создания лишних экземпляров класса или вообще 
переписать этот участок кода в функциональном стиле.</p>
<p>По этой же причине не рекомендуется плодить у себя в проекте кучу маленьких 
классов, реализующих буквально несколько методов.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://habr.com/ru/post/140581/">Перестаньте писать классы</a></li>
</ul>
<p><a name='Поиск-(lookup)-очень-дорогой'></a></p>
<h4>Поиск (lookup) очень дорогой</h4>
<p>Операции поиска:</p>
<ul>
<li>локальных/глобальных переменных</li>
<li>замыкания</li>
<li>атрибутов/методов</li>
</ul>
<p>Это ОЧЕНЬ ДОРОГИЕ операции и 90% времени python занимается именно этим, по 
этому нужно быть с этим очень осторожным.</p>
<p>Для оптимизации кода, нужно запомнить в локальные переменные все, что нам нужно.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">list_create</span>():
    res <span style="color: #666666">=</span> []
    __append <span style="color: #666666">=</span> res<span style="color: #666666">.</span>append
    <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #40a070">10</span>):
        __append(<span style="color: #007020">input</span>(<span style="color: #4070a0">&#39;Введите данные: &#39;</span>))
</code></pre></div>
<p>Так как мы 1 раз нашли метод append и сохранили его в свою локальную 
переменную, то в цикле мы не выполняем многократно дорогостоящий поиск, а 
вызываем нужный метод из локальной переменной.</p>
<p>Если наша функция list_create должна выполняться много раз, то глупо будет 
постоянно инициализировать наши локальные переменные, предназначены для 
запоминания часто используемых функциий. Для оптимизации этого момента можно 
использовать coroutines.</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">coroutine</span>(func):
    <span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">wrapper</span>(<span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs):
        gen <span style="color: #666666">=</span> func(<span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs)
        <span style="color: #007020">next</span>(gen)
        <span style="color: #007020; font-weight: bold">return</span> gen
    <span style="color: #007020; font-weight: bold">return</span> wrapper

<span style="color: #555555; font-weight: bold">@coroutine</span>
<span style="color: #007020; font-weight: bold">def</span> <span style="color: #06287e">list_create</span>():
    args <span style="color: #666666">=</span> ()
    res <span style="color: #666666">=</span> []
    __append <span style="color: #666666">=</span> res<span style="color: #666666">.</span>append
    __clear <span style="color: #666666">=</span> res<span style="color: #666666">.</span>clear
    <span style="color: #007020; font-weight: bold">while</span> <span style="color: #007020; font-weight: bold">True</span>:
        __clear()
        <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> args:
            __append(i)
        args <span style="color: #666666">=</span> <span style="color: #007020; font-weight: bold">yield</span> res

list_create_cor <span style="color: #666666">=</span> list_create()
<span style="color: #007020">print</span>(list_create_cor<span style="color: #666666">.</span>send((<span style="color: #4070a0">&#39;foo&#39;</span>, <span style="color: #4070a0">&#39;spam&#39;</span>, <span style="color: #4070a0">&#39;list&#39;</span>)))
</code></pre></div>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://youtu.be/4CsOOfdoU2A">Иван Ремизов - Сверхоптимизация кода на Python</a>, <a href="https://cloud.mail.ru/public/35XE/2AcgrAM3a">Копия</a></li>
</ul>
<p><a name='Ввод/вывод-(python-3.X)'></a></p>
<h4>Ввод/вывод (python 3.X)</h4>
<p>Функция <code>input</code> реализует дополнительную логику, по этому если нужно считывать 
данные со стандартного ввода и делать это очень быстро, то лучше напрямую 
обращаться к <code>sys.stdin</code>.</p>
<p>Считывать c stdin можно с помощью 2 методов:</p>
<ul>
<li><code>read()</code> - читает данные до тех пор, пока не будет получен EOF (обычно это Ctrl+D)</li>
<li><code>readline()</code> - читает до тех пор, пока не будет нажат Entre.</li>
</ul>
<p><strong>Пример задачи, где это может пригодиться:</strong></p>
<p>Ограничения: 1.5 секунды, 64 МБ памяти
На стандартный ввод программе сначала передаётся количество чисел, которые 
нужно считать, потом происходит ввод этих чисел. После этого опять передаётся 
количество чисел, которые нужно будет считать и после последовательно вводятся
эти числа.</p>
<p>Вы должны вывести одно число — количество чисел во втором списке, которые 
также содержатся в первом.</p>
<p>Пример входных данных:</p>
<table>
<thead>
<tr>
<th>Входные данные</th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1054</td>
<td></td>
</tr>
<tr>
<td>1492</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
</tr>
<tr>
<td>1492</td>
<td></td>
</tr>
<tr>
<td>65536</td>
<td></td>
</tr>
<tr>
<td>1492</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td></td>
</tr>
</tbody>
</table>
<p>Решение с использованием <code>input</code></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>required_size <span style="color: #666666">=</span> <span style="color: #007020">int</span>(<span style="color: #007020">input</span>())
required <span style="color: #666666">=</span> {<span style="color: #007020">input</span>() <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(required_size)}

written_size, result <span style="color: #666666">=</span> <span style="color: #007020">int</span>(<span style="color: #007020">input</span>()), <span style="color: #40a070">0</span>
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(written_size):
    result <span style="color: #666666">+=</span> <span style="color: #007020">input</span>() <span style="color: #007020; font-weight: bold">in</span> required

<span style="color: #007020">print</span>(result)
</code></pre></div>
<p>Решение с использованием прямого чтения из <code>sys.stdin</code></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">sys</span>

required_size <span style="color: #666666">=</span> <span style="color: #007020">int</span>(sys<span style="color: #666666">.</span>stdin<span style="color: #666666">.</span>readline())
required <span style="color: #666666">=</span> {sys<span style="color: #666666">.</span>stdin<span style="color: #666666">.</span>readline() <span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(required_size)}

written_size, result <span style="color: #666666">=</span> <span style="color: #007020">int</span>(sys<span style="color: #666666">.</span>stdin<span style="color: #666666">.</span>readline()), <span style="color: #40a070">0</span>
<span style="color: #007020; font-weight: bold">for</span> i <span style="color: #007020; font-weight: bold">in</span> <span style="color: #007020">range</span>(written_size):
    result <span style="color: #666666">+=</span> sys<span style="color: #666666">.</span>stdin<span style="color: #666666">.</span>readline() <span style="color: #007020; font-weight: bold">in</span> required

<span style="color: #007020">print</span>(result)
</code></pre></div>
<p>Если решать в лоб и использовать input(), то программа выполнится за 1.528, 
а если на прямую читать с sys.stdin, то программа выполнится за 0.858.</p>
<p><a name='Оптимизация-потребления-памяти,-способы-поиска-утечек-памяти'></a></p>
<h4>Оптимизация потребления памяти, способы поиска утечек памяти</h4>
<p>Материалы по теме:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=D0vbuIDOV4c">«Память и Python. Что надо знать для счастья?» Алексей Кузьмин, ЦНС</a>, 
  <a href="https://cloud.mail.ru/public/485j/5dzHRTWb8">Локальная копия доклада</a>,</li>
</ul>
<p><a name='Deploy'></a></p>
<h2>Deploy</h2>
<p><a name='Публикация-библиотеки-в-PyPi'></a></p>
<h3>Публикация библиотеки в PyPi</h3>
<p>Опубликовать библиотеку в pypi очень просто, а если в проекте используется 
poetry, то и не понадобится устанавливать никаких дополнительных утилит.</p>
<p>Перед тем как спешить опубликовать библиотеку в PyPi нужно знать, что 
после загрузки опубликованную библиотеку нельзя будет исправить и загрузить 
повторно не подняв версию. Поэтому к публикации нужно подходить с умом и 
действовать осторожно, а если необходимо произвести пробную загрузку, то можно 
воспользоваться тестовой средой, которая доступна 
по <a href="https://test.pypi.org">ссылке</a>.</p>
<p>Подготовка к загрузке:</p>
<ul>
<li>
<p>перейдите в корень проекта и добавьте ссылки на репозитории PyPi</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>poetry config repositories.pypi https://upload.pypi.org/legacy/
poetry config repositories.test_pypi https://test.pypi.org/legacy/
</code></pre></div>
</li>
<li>
<p>получите токен, позволяющий работать с API PyPi. Если токен ранее не 
  создавался, то создать его можно, перейдя в 
  <a href="https://pypi.org/manage/account/">настройки аккаунта</a>, в разделе <code>API tokens</code>.</p>
</li>
</ul>
<p>Сборка и публикация:</p>
<ol>
<li>
<p>Собираем библиотеку <code>poetry build</code></p>
</li>
<li>
<p>Загружаем собранную библиотеку в тестовый репозиторий</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>poetry publish -r test_pypi -u __token__ -p &lt;токен&gt;
</code></pre></div>
<blockquote>
<p>При авторизации, при помощи токена, логин всегда будет <code>__token__</code>.</p>
</blockquote>
<p>После загрузки найти библиотеку можно <a href="https://test.pypi.org/manage/projects/">тут</a>.</p>
<p>Если загрузка прошла успешно, можно приступать к загрузке в основной репозиторий:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>poetry publish -r pypi -u __token__ -p &lt;токен&gt;
</code></pre></div>
<p>Загруженную библиотеку можно найти <a href="https://pypi.org/manage/projects/">здесь</a>.</p>
</li>
</ol>
<p><a name='Namespace-packages'></a></p>
<h3>Namespace packages</h3>
<p>Иногда есть необходимость разделить 1 библиотеку на несколько отдельных библиотек
имеющих 1 namespace (одно общее имя), которые будут ставиться по отдельности, по 
необходимости. В этом случае вам может пригодиться механизм namespace packages.</p>
<p>Рассмотрим это на примере. На пример мы хотим иметь библиотеку имеющую следующую 
структуру:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>namespace
    package1
        module1.py
    package2
        module2.py
</code></pre></div>
<p>Где package1 и package2 будут распространяться отдельно, как две разные библиотеки.
Таким образом структура проектов будет выглядеть вот так:</p>
<p><strong>package1</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>namespace
    package1
        module1.py
</code></pre></div>
<p><strong>package2</strong></p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code>namespace
    package2
        module2.py
</code></pre></div>
<p>Для того, чтобы эта схема работала и вы в этих проектах могли спокойно импортировать
модули текущего проекта и модули принадлежащие этому пакету, которые распространяются
в виде отдельных библиотек внутри пакета у вас не должно быть <code>__init__.py</code> модуля.
Так как в соотвествии с PEP 420, если python находит в namespace <code>__init__.py</code>, то он 
перестает искать дальше, даже если там не был найден искомый модуль. Таким образом вы
можете получить ошибку вида <code>ModuleNotFoundError: No module named 'namespace1.package2'</code>.</p>
<blockquote>
<p>Важно заметить, что PEP 420 был внедрен начиная с python 3.3. По этому только начиная
с этой версии вы можете не создавать в пакете модуль <code>__init__.py</code> и папка будет 
распознана как пакет.</p>
</blockquote>
<p>В случае, если вам необходимо иметь модуль <code>__init__.py</code> в корне вашего подпроекта.
Вы должны добавить в него следующий код, который явно объявит простраство имен и 
поиск не будет прекращаться на первом найденном пакете:</p>
<div class="highlight" style="background: #f0f0f0"><pre style="line-height: 125%;"><span></span><code><span style="color: #007020; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">pkgutil</span> <span style="color: #007020; font-weight: bold">import</span> extend_path

__path__ <span style="color: #666666">=</span> extend_path(__path__, <span style="color: #bb60d5">__name__</span>)
</code></pre></div>
<p>Заметка основана на:</p>
<ul>
<li><a href="https://habr.com/ru/articles/458432/">Объединение нескольких пакетов в одно пространство имен Python - habr</a></li>
<li><a href="https://peps.python.org/pep-0420/">PEP 420 – Implicit Namespace Packages</a></li>
</ul>
<p><a name='Тестирование'></a></p>
<h2>Тестирование</h2>
<p><a name='Основы-тестирования'></a></p>
<h3>Основы тестирования</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=npJVGhmQSU4">Вадим Пуштаев - Юнит-тесты в проектах Поиска mail.ru</a>, <a href="https://cloud.mail.ru/public/4oGW/gWYu8tKNV">Копия</a></li>
</ul>
<p><a name='Mock'></a></p>
<h3>Mock</h3>
<p>Работа с моками не всегда тривиальна и иногда нужна шпаргалка, которая поможет вспомнить как реализовать тот или иной 
распространенный кейс. Для этого, я создал простой проект, в котором на примитивных примерах показываю как использовать
ту или иную функциональность моков. Вы можете ознакомиться с ним по <a href="https://gitlab.com/alex925/mock-example">ссылке</a>.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://habr.com/ru/post/141209/">Модуль Mock: макеты-пустышки в тестировании - habr</a></li>
<li><a href="https://stackoverflow.com/questions/33585431/mock-a-class-and-a-class-method-in-python-unit-tests">Mock a class and a class method in python unit tests - stackoverflow</a></li>
<li><a href="https://habr.com/ru/post/116372/">Unit-тесты, пытаемся писать правильно, чтобы потом не было мучительно больно - habr</a></li>
</ul>
<p><a name='Разное'></a></p>
<h2>Разное</h2>
<p><a name='Работа-с-датой-и-временем'></a></p>
<h3>Работа с датой и временем</h3>
<p>Стандартная библиотека имеет не до конца продуманное API работы с датой и 
временем, именно по этому была создана библиотека
<a href="https://arrow.readthedocs.io/en/latest/">arrow</a>. Она представляет из себя 
замену стандартного модуля datetime. </p>
<p>Если в вашем приложении необходимо много 
работать с датой и временем, то рекомендуется использовать именно эту 
библиотеку.</p>
<p>Для того, чтобы узнать подробности о проблемах работы с датой и временем
прочитайте следующие статьи:</p>
<ul>
<li><a href="https://asvetlov.blogspot.com/2011/02/date-and-time.html">Питон: времена, даты и временные зоны - Андрей Светлов</a>, <a href="https://cloud.mail.ru/public/2DTf/245vSkJmp">локальная копия</a></li>
<li><a href="https://djbook.ru/rel1.9/topics/i18n/timezones.html">Часовые пояса - документация django</a></li>
<li><a href="../computer-science/computer-science-index.html#Работа-с-датой-и-временем">Работа с датой и временем</a></li>
</ul>

        </div><!--/.col-xs-12.col-sm-9-->

    </div><!--/row-->


    <hr>

    <footer>
        <p>
            При копировании информации с данного сайта пожалуйста указывайте
            ссылку на источник. © 2019 Записки питониста
        </p>
    </footer>

</div><!--/.container-->


<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
        integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
        crossorigin="anonymous"></script>
</body>
</html>